<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>健身分化计划，时间分配，动作记录</title>
    <url>/2022/11/17/%E5%81%A5%E8%BA%AB%E5%88%86%E5%8C%96%E8%AE%A1%E5%88%92%EF%BC%8C%E6%97%B6%E9%97%B4%E5%88%86%E9%85%8D%EF%BC%8C%E5%8A%A8%E4%BD%9C%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="分化训练-约-3-分化"><a href="#分化训练-约-3-分化" class="headerlink" title="分化训练 - 约 3 分化"></a>分化训练 - 约 3 分化</h1><p>胸</p>
<p>背</p>
<p>腿</p>
<p>肩</p>
<p>手臂的二头可以在宿舍练，三头可以作为间歇组</p>
<h1 id="时间分配"><a href="#时间分配" class="headerlink" title="时间分配"></a>时间分配</h1><p>周六锻炼</p>
<p>周日不练</p>
<p>工作日根据时间选择 3 ~ 4 天锻炼</p>
<h1 id="动作记录"><a href="#动作记录" class="headerlink" title="动作记录"></a>动作记录</h1><p>a，b，c：组数，个数，重量（重量块，kg）的三元组</p>
<p>全流程：指这个动作，某肌肉全程参与</p>
<p>全行程：指这个动作，某肌肉从完全收缩到完全拉伸的全部行程，均有涵盖</p>
<p>离心： 指某个动作的反向动作，此时目标肌群在做拉伸，可以更充分的锻炼肌群（离心重量不宜过大）</p>
<h2 id="胸"><a href="#胸" class="headerlink" title="胸"></a>胸</h2><h3 id="蝴蝶机夹胸-热身组"><a href="#蝴蝶机夹胸-热身组" class="headerlink" title="蝴蝶机夹胸 - 热身组"></a>蝴蝶机夹胸 - 热身组</h3><p><strong>3，12，3|4</strong></p>
<h3 id="杠铃，哑铃卧推-力量组"><a href="#杠铃，哑铃卧推-力量组" class="headerlink" title="杠铃，哑铃卧推 - 力量组"></a>杠铃，哑铃卧推 - 力量组</h3><p><strong>4 - 10 - 30 kg</strong></p>
<p>哑铃重量适当下降</p>
<h3 id="杠铃，哑铃斜上卧推-力量组"><a href="#杠铃，哑铃斜上卧推-力量组" class="headerlink" title="杠铃，哑铃斜上卧推 - 力量组"></a>杠铃，哑铃斜上卧推 - 力量组</h3><p><strong>4 - 10 - 20 kg</strong></p>
<p>哑铃重量适当下降</p>
<h3 id="绳索单侧夹胸-训练组，间歇组"><a href="#绳索单侧夹胸-训练组，间歇组" class="headerlink" title="绳索单侧夹胸 - 训练组，间歇组"></a>绳索单侧夹胸 - 训练组，间歇组</h3><p><strong>4，12，4</strong></p>
<p>根据龙门架滑轮位置，分为上，中，下</p>
<p>重量不宜太大</p>
<p>握把一定要越过人体中线，保证胸肌的<strong>全流程</strong>，<strong>全行程</strong>参与</p>
<p>到达终点可以短暂停顿</p>
<p>适当做离心</p>
]]></content>
      <tags>
        <tag>work out</tag>
      </tags>
  </entry>
  <entry>
    <title>研究生生活工作时间表</title>
    <url>/2022/11/17/%E7%A0%94%E7%A9%B6%E7%94%9F%E7%94%9F%E6%B4%BB%E5%B7%A5%E4%BD%9C%E6%97%B6%E9%97%B4%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="非训练日"><a href="#非训练日" class="headerlink" title="非训练日"></a>非训练日</h1><p>07：20 起床</p>
<p>08：00 工作</p>
<p>11：00 午饭，午休</p>
<p>13：00 工作</p>
<p>17：00 晚饭</p>
<p>18：30 工作</p>
<p>20：30 下班</p>
<p>后面时间根据工作进展自由分配</p>
<p>22：30 下班</p>
<h1 id="训练日"><a href="#训练日" class="headerlink" title="训练日"></a>训练日</h1><p>07：20 起床</p>
<p>08：00 工作</p>
<p>11：00 午饭，午休</p>
<p>13：00 工作</p>
<p>17：00 健身房，晚饭</p>
<p>后面时间根据工作进展自由分配</p>
<p>22：30 下班</p>
<p><strong>训练第二天可以晚起一会</strong></p>
]]></content>
      <tags>
        <tag>plan</tag>
      </tags>
  </entry>
  <entry>
    <title>秋冬季节健身指南</title>
    <url>/2022/11/10/%E7%A7%8B%E5%86%AC%E5%AD%A3%E8%8A%82%E5%81%A5%E8%BA%AB%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>近期因为健身后不注意保暖重感冒一次，如果不是身体比较强壮，高概率是个发烧</p>
<p>吃一堑长一智，记录一下天寒时健身的注意事项</p>
<h1 id="关于健身"><a href="#关于健身" class="headerlink" title="关于健身"></a>关于健身</h1><p>休息的时候避免久坐，防止晾汗、肌肉过冷却</p>
<p>可以用手臂的小重量组，填充大重量组中间的部分休息时间</p>
<p>如：卧推组间，龙门架绳索下拉练三头，或者直杠划船，或者小重量坐地上拉背</p>
<h1 id="关于衣物"><a href="#关于衣物" class="headerlink" title="关于衣物"></a>关于衣物</h1><p><strong>不要太少</strong></p>
<p>热身完感觉身体微微发热，但没有明显的出汗，是最好的状态</p>
<p>此时肌肉活力处于高值，受伤概率较低</p>
<h1 id="关于路程"><a href="#关于路程" class="headerlink" title="关于路程"></a>关于路程</h1><p><strong>骑电动车</strong></p>
<p>不能骑自行车，身体无法处理冷风下的二次发热问题</p>
<p>衣物尽量厚一点</p>
<p>洗完澡应充分擦干燥，再穿衣服（去买一个大号的全身浴巾）</p>
<p>贴身一件应该是运动背心性质的衣服，透气性好，不容易堆积热量</p>
]]></content>
      <tags>
        <tag>work out</tag>
      </tags>
  </entry>
  <entry>
    <title>时间分配指南</title>
    <url>/2022/11/09/%E6%97%B6%E9%97%B4%E5%88%86%E9%85%8D%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>讲课尽量靠前，避免跟考试，作业挤在一起</p>
<p>中午回宿舍休息一下，11 点到 13 点，留点时间看看书</p>
<p>晚上看看书，或者是感兴趣的电影，整块的休息时间应完全放弃短视频</p>
<p>有电动车了，主观时间进一步收敛，还是要再次优化时间分配（F）</p>
]]></content>
      <tags>
        <tag>plan</tag>
      </tags>
  </entry>
  <entry>
    <title>Notebook - module</title>
    <url>/2022/10/30/Notebook%20-%20module/</url>
    <content><![CDATA[<h2 id="Thesis-Statement"><a href="#Thesis-Statement" class="headerlink" title="Thesis Statement"></a>Thesis Statement</h2><h2 id="Main-Contribution"><a href="#Main-Contribution" class="headerlink" title="Main Contribution"></a>Main Contribution</h2><h2 id="New-Knowledge"><a href="#New-Knowledge" class="headerlink" title="New Knowledge"></a>New Knowledge</h2><h2 id="Words-and-Phrases"><a href="#Words-and-Phrases" class="headerlink" title="Words and Phrases"></a>Words and Phrases</h2><h2 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h2><h2 id="Good-Sentences"><a href="#Good-Sentences" class="headerlink" title="Good Sentences"></a>Good Sentences</h2>]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>scientific research</tag>
      </tags>
  </entry>
  <entry>
    <title>Notebook - Distributed Secure Cooperative Control Under Denial-of-Service Attacks From Multiple Adversaries</title>
    <url>/2022/10/30/Notebook%20-%20Distributed-Secure-Cooperative-Control-Under-Denial-of-Service-Attacks-From-Multiple-AdversariesWen/</url>
    <content><![CDATA[<p> 10.30 He</p>
<h2 id="Thesis-Statement"><a href="#Thesis-Statement" class="headerlink" title="Thesis Statement"></a>Thesis Statement</h2><h2 id="Main-Contribution"><a href="#Main-Contribution" class="headerlink" title="Main Contribution"></a>Main Contribution</h2><h2 id="New-Knowledge"><a href="#New-Knowledge" class="headerlink" title="New Knowledge"></a>New Knowledge</h2><p>Zeno behavior: 事件连续触发，消耗更大</p>
<h2 id="Words-and-Phrases"><a href="#Words-and-Phrases" class="headerlink" title="Words and Phrases"></a>Words and Phrases</h2><p>asymptotic consensus  渐进一致性</p>
<p>denote 标志，预示</p>
<p>prominent 重要的</p>
<h2 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h2><h2 id="Good-Sentences"><a href="#Good-Sentences" class="headerlink" title="Good Sentences"></a>Good Sentences</h2><p>the $\cdots$ is hardly guaranteed, as many bad shits emerge, such as $\cdots$</p>
]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>scientific research</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式教程</title>
    <url>/2022/10/30/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>正则表达式被大部分语言所支持</p>
<p>尤其在库依赖，版本控制中大量使用，对于版本号的软硬控制有很强的实用性</p>
<p>简单写一个教程</p>
]]></content>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetbrain 全家桶快捷键</title>
    <url>/2022/10/25/Jetbrain-%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h1 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h1><div class="table-container">
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>ctrl + shift + S</td>
<td>打开 setting</td>
</tr>
<tr>
<td>ctrl + D</td>
<td>复制本行去下一行</td>
</tr>
<tr>
<td>ctrl + alt + L</td>
<td>Format code</td>
</tr>
<tr>
<td>ctrl + F</td>
<td>本文件 search</td>
</tr>
<tr>
<td>ctrl +shift + F</td>
<td>全文件 search</td>
</tr>
<tr>
<td>ctrl + R</td>
<td>本文件 replace</td>
</tr>
<tr>
<td>ctrl +shift + R</td>
<td>全文件 replace</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>laravel vue-element-admin 安装指南</title>
    <url>/2022/10/22/laravel-vue-element-admin-%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p><a href="http://www.phpxs.com/post/8290/" target="_blank" rel="noopener">参考教程</a></p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p><em>php: ^7.4</em></p>
<p><em>laravel: 7.*</em></p>
<p><em>element: ^2.13.2</em></p>
<p><em>vue: ^2.6.10</em></p>
<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h5 id="安装项目"><a href="#安装项目" class="headerlink" title="安装项目"></a>安装项目</h5><p>更具体内容见 <a href="https://squ1rrel-k.github.io/2022/10/14/Laravel-Vue-%E9%A1%B9%E7%9B%AE%E6%9C%AC%E5%9C%B0%E5%8C%96%E9%83%A8%E7%BD%B2/" target="_blank" rel="noopener">此教程</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> composer create-project laravel/laravel YourProjectName --prefer-dist <span class="string">"7.*"</span></span></span><br></pre></td></tr></table></figure>
<h5 id="安装-vue-element-admin"><a href="#安装-vue-element-admin" class="headerlink" title="安装 vue-element-admin"></a>安装 vue-element-admin</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/PanJiaChen/vue-element-admin.git</span></span><br></pre></td></tr></table></figure>
<h5 id="合并-package-json"><a href="#合并-package-json" class="headerlink" title="合并 package.json"></a>合并 package.json</h5><p>将 vue-element-admin 中 package.json 的 dependencies，devDependencies </p>
<p>合并到 laravel 的 package.json 中</p>
<p>以 vue-element-admin 为主</p>
<h5 id="复制-babel-config-js-到-laravel-根目录"><a href="#复制-babel-config-js-到-laravel-根目录" class="headerlink" title="复制 babel.config.js 到 laravel 根目录"></a>复制 babel.config.js 到 laravel 根目录</h5><h5 id="复制项目"><a href="#复制项目" class="headerlink" title="复制项目"></a>复制项目</h5><p>将 vue-element-admin 中整个 src 目录下的文件复制到 laravel 项目中的 resources/vue-element-admin 目录中</p>
<h5 id="npm-安装"><a href="#npm-安装" class="headerlink" title="npm 安装"></a>npm 安装</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm run dev</span></span><br></pre></td></tr></table></figure>
<h1 id="部分问题"><a href="#部分问题" class="headerlink" title="部分问题"></a>部分问题</h1><h5 id="别名定义"><a href="#别名定义" class="headerlink" title="别名定义"></a>别名定义</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Module not found: Error: Can't resolve '@/views/zip/index' in '/path/to/laravel-vue-admin/resources/backend/router'</span><br></pre></td></tr></table></figure>
<p>在 webpack.mix.js 中增加项目 src 目录的别名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.mix.js</span></span><br><span class="line">mix.webpackConfig(&#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">'@'</span>: path.resolve(__dirname, <span class="string">'resources/vue-element-admin/src'</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="babel-失败"><a href="#babel-失败" class="headerlink" title="babel 失败"></a>babel 失败</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Module build failed (from ./node_modules/babel-loader/lib/index.js):</span><br></pre></td></tr></table></figure>
<p>复制 babel.config.js 到 laravel 根目录</p>
<h5 id="字体加载失败"><a href="#字体加载失败" class="headerlink" title="字体加载失败"></a>字体加载失败</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> error  in ./resources/vue-element/src/assets/font/DS-DIGIT.TTF</span><br><span class="line"></span><br><span class="line">Module parse failed: Unexpected character '' (1:0)</span><br><span class="line">You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders</span><br></pre></td></tr></table></figure>
<p>安装 npm 的 file-loader，ttf-loader</p>
<p>并在 webpack.mix.js 中增加关于新的 module loader 的 webpack config </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install file-loader ttf-loader -D</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.mix.js</span></span><br><span class="line">mix.webpackConfig(&#123;</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line">            <span class="string">'@'</span>: path.resolve(__dirname, <span class="string">'resources/vue-element/src'</span>),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//加入新的 module 的加载规则</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.TTF$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'file-loader'</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            name: <span class="string">'./font/[hash].[ext]'</span>,</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="图片不显示"><a href="#图片不显示" class="headerlink" title="图片不显示"></a>图片不显示</h5> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">src=[object module]</span><br></pre></td></tr></table></figure>
<p> vue 默认使用的是 commonjs，webpack ^4.* 使用的是 es6 语法，两边任意一边凑过去都可以</p>
<p>可以在 webpack.mix.js 的 rules 中加入以下（但是没有解决我的问题）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.(png|jpe?g|gif|svg)$/</span>,</span><br><span class="line">  loader: <span class="string">'url-loader'</span>,</span><br><span class="line">  options: &#123;</span><br><span class="line">    esModule: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或可以降低 file-loader 的版本</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install file-loader@3.*</span></span><br></pre></td></tr></table></figure>
<h5 id="最后的-webpack-mix-js"><a href="#最后的-webpack-mix-js" class="headerlink" title="最后的 webpack.mix.js"></a>最后的 webpack.mix.js</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.mix.js</span></span><br><span class="line"><span class="keyword">const</span> mix = <span class="built_in">require</span>(<span class="string">'laravel-mix'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> |--------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> | Mix Asset Management</span></span><br><span class="line"><span class="comment"> |--------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> | Mix provides a clean, fluent API for defining some Webpack build steps</span></span><br><span class="line"><span class="comment"> | for your Laravel application. By default, we are compiling the Sass</span></span><br><span class="line"><span class="comment"> | file for the application as well as bundling up all the JS files.</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">mix.js(<span class="string">'resources/vue-element/src/main.js'</span>, <span class="string">'public/js'</span>)</span><br><span class="line">    .sass(<span class="string">'resources/sass/app.scss'</span>, <span class="string">'public/css'</span>);</span><br><span class="line"></span><br><span class="line">mix.webpackConfig(&#123;</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line">            <span class="string">'@'</span>: path.resolve(__dirname, <span class="string">'resources/vue-element/src'</span>),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.TTF$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'file-loader'</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            name: <span class="string">'./font/[hash].[ext]'</span>,</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>科研兴趣点</title>
    <url>/2022/10/21/%E7%A7%91%E7%A0%94%E5%85%B4%E8%B6%A3%E7%82%B9/</url>
    <content><![CDATA[<p>博弈论</p>
<p>人工智能</p>
<p>机器学习</p>
<p>政治经济学</p>
<p>社会学</p>
<p>数学分析</p>
<p>高等代数</p>
]]></content>
      <tags>
        <tag>scientific research</tag>
      </tags>
  </entry>
  <entry>
    <title>讲座笔记-洪奕光-复杂多智能体系统的分析与调控</title>
    <url>/2022/10/21/%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0-%E6%B4%AA%E5%A5%95%E5%85%89-%E5%A4%8D%E6%9D%82%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E6%8E%A7/</url>
    <content><![CDATA[<p><strong>一定要找具体的研究问题是什么！</strong></p>
<h1 id="观点"><a href="#观点" class="headerlink" title="观点"></a>观点</h1><p>做科研一定要找具体的研究问题是什么，泛泛而谈难度太高</p>
<p>努力做交叉</p>
<p>国家的判断：新的突破点在学科交叉</p>
<p>人工智能很重要，不要拒绝机器学习</p>
<p>博弈论是天然的多智能体系统，现在没有特别热门是因为智能体还不够智能</p>
<p>社会网络跟博弈论的结合是趋势</p>
<h1 id="复杂网络多智能体在社会学上的应用"><a href="#复杂网络多智能体在社会学上的应用" class="headerlink" title="复杂网络多智能体在社会学上的应用"></a>复杂网络多智能体在社会学上的应用</h1><p>提出了若干改进模型</p>
<p>应用：尝试解释巴黎协定各国间的动力学行为</p>
<p>问题：观测器难以建立，控制器设计必须足够温柔</p>
]]></content>
      <tags>
        <tag>scientific research</tag>
      </tags>
  </entry>
  <entry>
    <title>数学分析读书笔记</title>
    <url>/2022/10/21/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><strong>数学是最高抽象的学科，不要尝试具体的理解所有理论，即使有数形结合跟其他学科的应用</strong></p>
<p><strong>数学是形而上的本能直觉</strong></p>
]]></content>
      <tags>
        <tag>scientific research</tag>
      </tags>
  </entry>
  <entry>
    <title>Notebook - Prescribed-Time Stabilization of Controllable Planar Systems Using Switched State Feedback</title>
    <url>/2022/10/17/Notebook%20-%20Prescribed-Time%20Stabilization%20of%20Controllable%20Planar%20Systems%20Using%20Switched%20State%20Feedback/</url>
    <content><![CDATA[<p>10.16   Tao</p>
<h2 id="Thesis-Statement"><a href="#Thesis-Statement" class="headerlink" title="Thesis Statement"></a>Thesis Statement</h2><p>double $u$, control to $0$</p>
<h2 id="Main-Contribution"><a href="#Main-Contribution" class="headerlink" title="Main Contribution"></a>Main Contribution</h2><p>Using switch state feedback to solve problems in </p>
<p>$u_1 + u_2$, double controller</p>
<p>From an arbitrarily small domain to $0$</p>
<p>Since $\mu=    \frac{T_1}{T_1-t}$, switch before $t =T_1$ (otherwise $\mu$ is infinite), so add $t_s$ and $R$ (a level set)</p>
<h2 id="New-Knowledge"><a href="#New-Knowledge" class="headerlink" title="New Knowledge"></a>New Knowledge</h2><p>prescribed time</p>
<p>finite time</p>
<p>level set</p>
<p>$sign()$ function</p>
<h2 id="Words-and-Phrases"><a href="#Words-and-Phrases" class="headerlink" title="Words and Phrases"></a>Words and Phrases</h2><p>ordinary differential equations 常微分方程</p>
<h2 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h2><h2 id="Good-Sentences"><a href="#Good-Sentences" class="headerlink" title="Good Sentences"></a>Good Sentences</h2><p>The approach is based on $\cdots$.</p>
<p>$\cdots$, governed by $\cdots$, remains an active research area.</p>
]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>scientific research</tag>
      </tags>
  </entry>
  <entry>
    <title>Laravel Vue 项目本地化部署</title>
    <url>/2022/10/14/Laravel-Vue-%E9%A1%B9%E7%9B%AE%E6%9C%AC%E5%9C%B0%E5%8C%96%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="项目拷贝"><a href="#项目拷贝" class="headerlink" title="项目拷贝"></a>项目拷贝</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:YourUserName/YourRepositories.git</span><br></pre></td></tr></table></figure>
<h1 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">composer install </span><br><span class="line">cp .env.example .env # Then modify .env file</span><br><span class="line">php artisan key:generate</span><br><span class="line">npm install</span><br><span class="line">npm install vue-loader vue-template-compiler --save-dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> modify webpack, add vue() to import chain</span></span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>tutorial</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>从递归到分治，贪心，动归</title>
    <url>/2022/10/13/%E4%BB%8E%E9%80%92%E5%BD%92%E5%88%B0%E5%88%86%E6%B2%BB%EF%BC%8C%E8%B4%AA%E5%BF%83%EF%BC%8C%E5%8A%A8%E5%BD%92/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>近期工作计划</title>
    <url>/2022/10/12/%E8%BF%91%E6%9C%9F%E5%B7%A5%E4%BD%9C%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h1 id="课程"><a href="#课程" class="headerlink" title="课程"></a>课程</h1><p>统计学 - 找论文</p>
<p>复杂网络 - 下周演讲</p>
<p>算法分析 - 准备考试</p>
<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><p>完成业务逻辑梳理</p>
<p>完成前后端接口的开发研究</p>
<p>完成 R 基础知识学习</p>
<h1 id="科研"><a href="#科研" class="headerlink" title="科研"></a>科研</h1><p>复杂网络导论</p>
<p>本周论文 - 看完 Abstract，等待组会学习</p>
<h1 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h1><p>3 分化</p>
<p>能在宿舍做的孤立动作不去健身房，注意关节热身</p>
<h1 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h1><p>头眼暂缓</p>
<p>狗 8 保持跟进</p>
<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
      <tags>
        <tag>plan</tag>
      </tags>
  </entry>
  <entry>
    <title>常用 Markdown 数学公式</title>
    <url>/2022/10/06/%E5%B8%B8%E7%94%A8-Markdown-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="上标-X-2"><a href="#上标-X-2" class="headerlink" title="上标 $X^2$"></a>上标 $X^2$</h1><p>X^2</p>
<h1 id="下标-X-2"><a href="#下标-X-2" class="headerlink" title="下标 $X_2$"></a>下标 $X_2$</h1><p>X_2</p>
<h1 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h1><p><a href="https://zhuanlan.zhihu.com/p/265517357" target="_blank" rel="noopener">怎么在LaTeX,Markdown和知乎上写数学公式时打出空格</a></p>
<p><img src="https://files.catbox.moe/fvmirs.jpg" alt="空格"></p>
<h3 id="大空格-x-quad-y"><a href="#大空格-x-quad-y" class="headerlink" title="大空格 $x\quad y$"></a>大空格 $x\quad y$</h3><p>x \quad y</p>
<h3 id="小空格-x-y"><a href="#小空格-x-y" class="headerlink" title="小空格 $x \, y$"></a>小空格 $x \, y$</h3><p>x \, y</p>
<h1 id="向量-vec-l"><a href="#向量-vec-l" class="headerlink" title="向量 $\vec{l}$"></a>向量 $\vec{l}$</h1><p>\vec{l}</p>
<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><script type="math/tex; mode=display">
\begin{matrix}
1 & 2 & 3 \\
   4 & 5 & 6 \\
   7 & 8 & 9
\end{matrix}</script><p>begin{matrix}<br>1 &amp; 2 &amp; 3 \\<br>   4 &amp; 5 &amp; 6 \\<br>   7 &amp; 8 &amp; 9<br>end{matrix}</p>
<p><strong>begin 跟 end 前面都要加 \</strong></p>
<h1 id="侧标"><a href="#侧标" class="headerlink" title="侧标"></a>侧标</h1><script type="math/tex; mode=display">
\begin{matrix}1 & 2 & 3 \\   4 & 5 & 6 \\   7 & 8 & 9 \end{matrix}\tag{1}</script><p>\tag{1}</p>
<h1 id="大于等于-geq"><a href="#大于等于-geq" class="headerlink" title="大于等于 $\geq$"></a>大于等于 $\geq$</h1><p>\geq</p>
<h1 id="小于等于-leq"><a href="#小于等于-leq" class="headerlink" title="小于等于 $\leq$"></a>小于等于 $\leq$</h1><p>\leq</p>
<h1 id="省略号-cdots"><a href="#省略号-cdots" class="headerlink" title="省略号 $\cdots$"></a>省略号 $\cdots$</h1><p>\cdots</p>
<h1 id="分号-frac-x-y"><a href="#分号-frac-x-y" class="headerlink" title="分号 $\frac{x}{y}$"></a>分号 $\frac{x}{y}$</h1><p>\frac 或 \dfrac</p>
]]></content>
      <categories>
        <category>tutorial</category>
      </categories>
      <tags>
        <tag>scientific research</tag>
      </tags>
  </entry>
  <entry>
    <title>从场论到图论：梯度，旋度，散度，通量，拉布拉斯算子与矩阵，图算法</title>
    <url>/2022/10/06/%E4%BB%8E%E5%9C%BA%E8%AE%BA%E5%88%B0%E5%9B%BE%E8%AE%BA%EF%BC%9A%E6%A2%AF%E5%BA%A6%EF%BC%8C%E6%97%8B%E5%BA%A6%EF%BC%8C%E6%95%A3%E5%BA%A6%EF%BC%8C%E9%80%9A%E9%87%8F%EF%BC%8C%E6%8B%89%E5%B8%83%E6%8B%89%E6%96%AF%E7%AE%97%E5%AD%90%E4%B8%8E%E7%9F%A9%E9%98%B5%EF%BC%8C%E5%9B%BE%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/67336297/" target="_blank" rel="noopener">【其实贼简单】拉普拉斯算子和拉普拉斯矩阵</a></p>
<h1 id="方向导数与梯度"><a href="#方向导数与梯度" class="headerlink" title="方向导数与梯度"></a>方向导数与梯度</h1><h5 id="偏导数：函数在坐标轴方向的变化率"><a href="#偏导数：函数在坐标轴方向的变化率" class="headerlink" title="偏导数：函数在坐标轴方向的变化率"></a>偏导数：函数在坐标轴方向的变化率</h5><h5 id="方向导数：函数在特定方向-l-的变化率"><a href="#方向导数：函数在特定方向-l-的变化率" class="headerlink" title="方向导数：函数在特定方向 $l$ 的变化率"></a>方向导数：函数在特定方向 $l$ 的变化率</h5><p>记作： ${ {\partial u \over \partial \vec{l} } | }_{P_0}$</p>
<h5 id="梯度：数量场某点方向导数，哪个方向最大？梯度！"><a href="#梯度：数量场某点方向导数，哪个方向最大？梯度！" class="headerlink" title="梯度：数量场某点方向导数，哪个方向最大？梯度！"></a>梯度：数量场某点方向导数，哪个方向最大？梯度！</h5><p>记作：${\vec{grad} {\,}u |}_{P_0}$，为函数三个方向的偏导数</p>
<p>梯度是向量，是最大变化率的方向导数</p>
<h1 id="通量"><a href="#通量" class="headerlink" title="通量"></a>通量</h1>]]></content>
      <tags>
        <tag>scientific research</tag>
      </tags>
  </entry>
  <entry>
    <title>M 矩阵</title>
    <url>/2022/10/06/M-%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<p><a href="https://wenku.baidu.com/view/dbe1224f2e3f5727a5e962df.html" target="_blank" rel="noopener">M-矩阵的应用简介</a></p>
<p>在计算数学，生物学，物理学与数理经济学等领域中，有许多问题可归结为具有特殊构造的矩阵问题</p>
<p>在这一类矩阵中，具有非正的非对角元素的实方阵扮演着重要的角色</p>
<p>M - 矩阵的术语在1937年首先有 Ostrowski 提出：</p>
<p>判定一个矩阵是否为 M 矩阵在网络计算中，可以判定一个离散动力系统是否稳定</p>
<p>在数值计算中，可以判定一个迭代系统是否收敛</p>
<p>因此研究 M 矩阵的判定方法成为矩阵理论研究中极为活跃的一领域</p>
<p>多年以来国内外许多数学工作者都在研究 M 矩阵的判定方法，已有的研究成果大多是对 M 矩阵的整体进行讨论。</p>
]]></content>
      <tags>
        <tag>scientific research</tag>
      </tags>
  </entry>
  <entry>
    <title>从《三体》到线性代数，矩阵，基，行列式的本质</title>
    <url>/2022/10/05/%E4%BB%8E%E3%80%8A%E4%B8%89%E4%BD%93%E3%80%8B%E5%88%B0%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%EF%BC%8C%E7%9F%A9%E9%98%B5%EF%BC%8C%E5%9F%BA%EF%BC%8C%E8%A1%8C%E5%88%97%E5%BC%8F%E7%9A%84%E6%9C%AC%E8%B4%A8/</url>
    <content><![CDATA[<p><a href="https://www.matongxue.com/madocs/247/" target="_blank" rel="noopener">行列式的本质是什么？</a></p>
<p>刘老师跟我们讲课的时候，从来没有把线性代数与高等数学加以区分，统言之：高等数学</p>
<p>我挺疑惑的，知道今天看了这篇文章才琢磨到一点味道</p>
<p>线性代数，线性代数，首先是线性的，那么 $y = x^2$ 必然不是研究对象，此类问题被限定在 $y = ax + b$ 上面，那么立即推，其为高等数学研究的一个很大的子问题</p>
<p>那么谁最擅长研究线性问题呢？矩阵嘛！</p>
<p>那么什么样的世界是离散的线性世界呢？计算机世界嘛！</p>
<p>于是计算机跟矩阵的关系开始暧昧起来~</p>
<h1 id="什么是矩阵"><a href="#什么是矩阵" class="headerlink" title="什么是矩阵"></a>什么是矩阵</h1><p>矩阵是线性变换的唯一工具</p>
<p>矩阵变换的目标对象是基</p>
<p>矩阵变换的倍率是行列式</p>
<p>矩阵变换的角度是矩阵以行列式为单位放缩后，得到的模为 $1$ 的矩阵，此矩阵控制变换的角度</p>
<h1 id="什么是基"><a href="#什么是基" class="headerlink" title="什么是基"></a>什么是基</h1><p>顾名思义，基，基石，是一个多维空间描述精确位置的基石</p>
<p>基于一个原点，最少的恰好能描述这个时空的基数量，就是这个时空的维度</p>
<h1 id="什么是行列式"><a href="#什么是行列式" class="headerlink" title="什么是行列式"></a>什么是行列式</h1><p>行列式是线性变换的伸缩因子</p>
<p>行列式的大小决定变化后，决定了向量，基连成的平行四边形的面积的变化（二维），即多边形的测度</p>
<p>立即推： $|A|&gt;0$ ，面积放大 ；$|A|&lt;0 $ ，面积缩小</p>
<p><strong>最有意思的地方来了，$|A|=0 $ 怎么说？</strong></p>
<p>按照之前的解释，行列式为 0，面积扩大（缩小）0 倍，说明维度严重受损，至少一个维度坍塌为 0，那么维持测度的基被严重打击，立即推变换后测度为 0</p>
<p>举例之：三维的基会坍塌为平面，直线或者点，无论是哪个，体积肯定是没有了</p>
<p>在《三体》里，三维生物不能理解四维坟墓的内外之分，就是因为维度缺失，我们可以把缺失的维度看成基为 $0$ 向量，$0$ 基于任何倍率也无法达到非 $0$ 的世界</p>
<p>毁灭一个世界有二向箔降维打击，而创造一个世界是高等文明都无法掌握的能力，这就是造物主的特权，从无到有的天堑，凡性难以僭越</p>
<p>所以说二向箔其实就是一个行列式为 $0$ ，有且只有一个 $0$ 特征值的大矩阵，对整个太阳系做了一次线性变换！</p>
<h1 id="矩阵可逆？"><a href="#矩阵可逆？" class="headerlink" title="矩阵可逆？"></a>矩阵可逆？</h1><p>维度不坍塌的线性变换，行列式不为 0 ，很显然反着来一次就行了，于是正反这俩矩阵就是一对可逆矩阵</p>
<p>而被二向箔作用过的世界，至少一个基已经被摧毁，再如何的矩阵来做线性变换，也不可能恢复如初了，称之为此矩阵不可逆，换言之此矩阵是残忍矩阵</p>
<p>大宇宙广播，无数高等文明的共识，从未觊觎通过文明的能力恢复不断降低的宇宙维度，而是把物质交还给宇宙，希望下一次的神迹，让宇宙在大爆炸的得以新生</p>
<p>给岁月以文明，而不是给文明以岁月</p>
<p>刘慈欣牛逼！</p>
]]></content>
      <tags>
        <tag>scientific research</tag>
      </tags>
  </entry>
  <entry>
    <title>部分知识补充</title>
    <url>/2022/10/05/%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<h1 id="范数-x"><a href="#范数-x" class="headerlink" title="范数 $||x||$"></a>范数 $||x||$</h1><p>定义了向量空间里的距离，使得向量之间的比较成为了可能</p>
<p>可以把一个实数列表，映射为一个数</p>
<p><strong>当维数超过三维，距离这个概念应该被进一步抽象，转为表示高维点之间的时空关系，便有了范数</strong></p>
<h5 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h5><p>L0 范数，向量非 0 元素个数，即稀疏度</p>
<p>L1 范数，曼哈顿距离：一个向量中所有元素的绝对值之和</p>
<p>L2 范数，欧几里得范数：是一个向量中所有元素取平方和，然后再开平方（向量的模）</p>
<h1 id="特征值"><a href="#特征值" class="headerlink" title="特征值"></a>特征值</h1><p>原空间某一个基在变换后，其空间的长度变化系数，$&gt;0$ 表示方向一致，$&lt;0$ 表示方向相反</p>
<p>变换后夹角 $&lt;90^\circ$，说明变换后的向量投影回原向量时方向不变</p>
<p>用特征值做限制可以更直观也更严格地表达出这一个特点</p>
<h1 id="奇异矩阵"><a href="#奇异矩阵" class="headerlink" title="奇异矩阵"></a>奇异矩阵</h1><p>行列式为 $0$，没有可逆矩阵好兄弟，可谓之奇异</p>
<h1 id="正定矩阵-positive-definite-matrix"><a href="#正定矩阵-positive-definite-matrix" class="headerlink" title="正定矩阵 positive-definite matrix"></a>正定矩阵 positive-definite matrix</h1><p><a href="https://zhuanlan.zhihu.com/p/345077039" target="_blank" rel="noopener">一个矩阵正定(Possitive definite) 到底能说明什么，能解决什么问题？</a></p>
<p>可以将正定矩阵理解为矩阵版标量正系数 [知乎，若辰]</p>
<p>线性代数是研究变换的，一个作用在向量上的矩阵正定，事实上是一个相当强的限制，其规定向量被变换后，方向不变</p>
<p>正定代表二次型系统在空间内有最优解问题</p>
<h1 id="对角占优矩阵"><a href="#对角占优矩阵" class="headerlink" title="对角占优矩阵"></a>对角占优矩阵</h1><h5 id="对角线元素比其他之和要大"><a href="#对角线元素比其他之和要大" class="headerlink" title="对角线元素比其他之和要大"></a>对角线元素比其他之和要大</h5><p>设 $A$ 是 $n$ 阶矩阵，若 $A$ 满足</p>
<script type="math/tex; mode=display">
|a_{ii}|\geq \sum_{j=1,j\neq i}^{n}|a_{ij}|, i=1,2 \cdots n,</script><p>至少一个严格不等式成立，$A$ 为弱对角占优；</p>
<p>每个严格不等式都成立，$A$ 为严格对角占优</p>
<p>严格对角占优矩阵具有<strong>非奇异性</strong></p>
<p>拉布拉斯矩阵显然不是严格对角占优矩阵</p>
<h1 id="拉布拉斯矩阵"><a href="#拉布拉斯矩阵" class="headerlink" title="拉布拉斯矩阵"></a>拉布拉斯矩阵</h1><p>通过任意方阵变换得到，具有良好的性质，有利于后面对其研究（不够准确！）</p>
<h1 id="M-矩阵"><a href="#M-矩阵" class="headerlink" title="M-矩阵"></a>M-矩阵</h1><p>方阵，非对角元非正，存在正定对角阵 $P$ ，使得 $PB+B^TP$ 为非负定阵，为 M-矩阵</p>
<p>若有 $0$ 特征值，为奇异 M-矩阵</p>
<p>拉布拉斯矩阵显然为奇异 M-矩阵</p>
<h1 id="置换矩阵"><a href="#置换矩阵" class="headerlink" title="置换矩阵"></a>置换矩阵</h1><p>如：</p>
<script type="math/tex; mode=display">
\begin{matrix}
1&0&0\\
0&0&1\\
0&1&0
\end{matrix}</script><p>根据左行右列定理，左乘做行变换，右乘做列变换，此矩阵将目标矩阵的 2，3 列交换</p>
<p>置换矩阵 $P$ 是方阵， $P$ 的每一行和每一列都有且仅有一个 1，其余均为 0</p>
<p>置换矩阵也可以看作单位矩阵 $I$ 的行重排列</p>
<p>$P^{-1} = P^{T}$</p>
<h1 id="可约矩阵"><a href="#可约矩阵" class="headerlink" title="可约矩阵"></a>可约矩阵</h1><h5 id="可约矩阵主要用来描述此矩阵-A-代表的有向图-S-A-是否具有强连通性"><a href="#可约矩阵主要用来描述此矩阵-A-代表的有向图-S-A-是否具有强连通性" class="headerlink" title="可约矩阵主要用来描述此矩阵 $A$ 代表的有向图 $S(A)$ 是否具有强连通性"></a>可约矩阵主要用来描述此矩阵 $A$ 代表的有向图 $S(A)$ 是否具有强连通性</h5><h1 id="线性矩阵不等式-LMI-一个求大矩阵正定的方法"><a href="#线性矩阵不等式-LMI-一个求大矩阵正定的方法" class="headerlink" title="线性矩阵不等式 (LMI) - 一个求大矩阵正定的方法"></a>线性矩阵不等式 (LMI) - 一个求大矩阵正定的方法</h1><h5 id="可以通过对大矩阵巧妙分块，使得把求其正定的问题，转化为求小矩阵正定"><a href="#可以通过对大矩阵巧妙分块，使得把求其正定的问题，转化为求小矩阵正定" class="headerlink" title="可以通过对大矩阵巧妙分块，使得把求其正定的问题，转化为求小矩阵正定"></a>可以通过对大矩阵巧妙分块，使得把求其正定的问题，转化为求小矩阵正定</h5><p>给定<strong>对称</strong>矩阵 $Q(x)$ 和 $R(x)$，和矩阵 $S(x)$， 有：</p>
<script type="math/tex; mode=display">
{\left[ \begin{matrix}
Q(x) & S(x)\\
S^T(x) & R(x)
\end{matrix}
\right ]} >0,</script><p>与以下两个不等式两两等价</p>
<p>(1) $Q(x)&gt;0, R(x)-S^T(x)Q(x)S(x)&gt;0$</p>
<p>(2) $R(x)&gt;0, Q(x)-S^T(x)R(x)S(x)&gt;0$</p>
<h1 id="引理，定理，定义，公理，命题，推论"><a href="#引理，定理，定义，公理，命题，推论" class="headerlink" title="引理，定理，定义，公理，命题，推论"></a>引理，定理，定义，公理，命题，推论</h1>]]></content>
      <tags>
        <tag>scientific research</tag>
      </tags>
  </entry>
  <entry>
    <title>一些科研的问题</title>
    <url>/2022/10/05/%E4%B8%80%E4%BA%9B%E7%A7%91%E7%A0%94%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="邻接矩阵为什么要求拉普拉斯矩阵？"><a href="#邻接矩阵为什么要求拉普拉斯矩阵？" class="headerlink" title="邻接矩阵为什么要求拉普拉斯矩阵？"></a>邻接矩阵为什么要求拉普拉斯矩阵？</h1><h1 id="拉布拉斯矩阵放弃了节点的内耦合，如何弥补？"><a href="#拉布拉斯矩阵放弃了节点的内耦合，如何弥补？" class="headerlink" title="拉布拉斯矩阵放弃了节点的内耦合，如何弥补？"></a>拉布拉斯矩阵放弃了节点的内耦合，如何弥补？</h1><h1 id="矩阵可以代表二次型，正定与否可以表示系统性质，那为什么系统就一定得是二次的？"><a href="#矩阵可以代表二次型，正定与否可以表示系统性质，那为什么系统就一定得是二次的？" class="headerlink" title="矩阵可以代表二次型，正定与否可以表示系统性质，那为什么系统就一定得是二次的？"></a>矩阵可以代表二次型，正定与否可以表示系统性质，那为什么系统就一定得是二次的？</h1><h1 id="很多模型出现了-theta-，-1-theta-，是为了凑某个线性关系吗？为什么不是-theta-，-2-theta"><a href="#很多模型出现了-theta-，-1-theta-，是为了凑某个线性关系吗？为什么不是-theta-，-2-theta" class="headerlink" title="很多模型出现了 $\theta$，$1-\theta$，是为了凑某个线性关系吗？为什么不是 $\theta$，$2-\theta$ ?"></a>很多模型出现了 $\theta$，$1-\theta$，是为了凑某个线性关系吗？为什么不是 $\theta$，$2-\theta$ ?</h1>]]></content>
      <tags>
        <tag>scientific research</tag>
      </tags>
  </entry>
  <entry>
    <title>技术短板与补充</title>
    <url>/2022/10/05/%E6%8A%80%E6%9C%AF%E7%9F%AD%E6%9D%BF%E4%B8%8E%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<h1 id="前端工作流："><a href="#前端工作流：" class="headerlink" title="前端工作流："></a>前端工作流：</h1><p>Sass</p>
<h1 id="版本控制："><a href="#版本控制：" class="headerlink" title="版本控制："></a>版本控制：</h1><p>深入了解 Github 工作流及常用功能</p>
<p>深入了解 Git 原理及工作流</p>
]]></content>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-A-1002</title>
    <url>/2022/09/29/PAT-A-1002/</url>
    <content><![CDATA[<h1 id="PAT-A-1002"><a href="#PAT-A-1002" class="headerlink" title="PAT-A-1002"></a>PAT-A-1002</h1><p><a href="https://github.com/Squ1rrel-K/PAT-A-CPP" target="_blank" rel="noopener">所有甲级题全解</a></p>
<p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805526272000000" target="_blank" rel="noopener">原题链接</a></p>
<h2 id="生僻词汇："><a href="#生僻词汇：" class="headerlink" title="生僻词汇："></a>生僻词汇：</h2><p>exponents  指数</p>
<p>coefficient 系数</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>两个多项式相加，系数不为整数</p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>在线处理</p>
<p>利用空间换解题复杂度</p>
<p><code>printf()</code> 的格式问题，<code>%.1f</code> 是输出一位小数，类推</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>$N$ 最多 为 1000，设置一个长度大于 1000 的数组，即可用角标代替指数，在线处理</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">double</span> arr[maxN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> k, n, cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> an;</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环2次，输入2个多项式</span></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在线处理</span></span><br><span class="line">        <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%lf"</span>, &amp;n, &amp;an);</span><br><span class="line">            arr[n] += an;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//非零项数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxN; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] != <span class="number">0</span>) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = maxN - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d %.1f"</span>, i, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PAT</category>
        <category>PAT A</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>研一第一学期工作计划</title>
    <url>/2022/09/28/%E7%A0%94%E4%B8%80%E7%AC%AC%E4%B8%80%E5%AD%A6%E6%9C%9F%E5%B7%A5%E4%BD%9C%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h1 id="研一第一学期工作计划"><a href="#研一第一学期工作计划" class="headerlink" title="研一第一学期工作计划"></a>研一第一学期工作计划</h1><p>打基础为主，重心放在项目跟基础知识构架</p>
<h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><p>重概念，轻计算，掌握主要框架知识为主要矛盾</p>
<p>408 为纲，计组，OS，DS，计网</p>
<p>计组：王道</p>
<p>OS：王道</p>
<p>DS：已熟练</p>
<p>计网：王道</p>
<h2 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h2><p>《网络科学导论》熟读，非精读，了解基本研究方向，更具体的工作方向等待刘院指导</p>
<h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><p>算法：熟练 PAT 甲级，完善解法分析代码库</p>
<p>网站开发：复习 Laravel L01，Laravel L02</p>
<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>前两个月做技术储备，后面先进行多智能体官网的开发，具体细节在技术储备结束后找胡老师</p>
<h2 id="课程"><a href="#课程" class="headerlink" title="课程"></a>课程</h2><p>《算法分析》：顺道复习 DS，跟进课程进度，但是看网课</p>
<h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><p>每周至少一次 vrchat 练习口语，争取 11 月 20 日的考试拿到免修的 C+ 等级</p>
<h2 id="练字"><a href="#练字" class="headerlink" title="练字"></a>练字</h2><p>钢笔，中文，英文</p>
<p>方法论还要去知乎查询</p>
<h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><p>头眼每周一期</p>
<p>每日花 1 h，做 20 min 的集锦，不做精剪</p>
<p>998 合作视频每周一期</p>
<p>每日 8 点半左右开小会</p>
<h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><p>每周至少 2 篇有质量的内容</p>
]]></content>
      <tags>
        <tag>plan</tag>
      </tags>
  </entry>
  <entry>
    <title>EditorConfig 使用说明</title>
    <url>/2022/09/20/EditorConfig-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h1 id="EditorConfig-使用说明"><a href="#EditorConfig-使用说明" class="headerlink" title="EditorConfig 使用说明"></a>EditorConfig 使用说明</h1><p>.EditorConfig 文件是为了保证跨 IDE 的代码一致性，以避免不同缩进方式带来的潜在安全问题</p>
<p>.EditorConfig 的优先级高于 IDE</p>
<h2 id="查询表"><a href="#查询表" class="headerlink" title="查询表"></a>查询表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 表示是最顶层的配置文件，发现值为true时，才会停止查找.editorconfig文件</span><br><span class="line">root</span><br><span class="line"> </span><br><span class="line"># 设置使用那种缩进风格(tab是制表符，space是空格)</span><br><span class="line">indent_style</span><br><span class="line"> </span><br><span class="line"># 定义用于每个缩进级别的空格数</span><br><span class="line">indent_size</span><br><span class="line"> </span><br><span class="line"># 用一个整数来设置tab缩进的列数。</span><br><span class="line">tab_width</span><br><span class="line"> </span><br><span class="line"># 设置换行符，值为lf、cr和crlf</span><br><span class="line">end_of_line</span><br><span class="line"> </span><br><span class="line"># 设置编码格式，值为latin1、utf-8、utf-8-bom、utf-16be和utf-16le</span><br><span class="line">charset</span><br><span class="line"> </span><br><span class="line"># 设置为true则删除换行符之前的任何空白字符</span><br><span class="line"># 设置为true会删除每一行后的任何空格  ***</span><br><span class="line">trim_trailing_whitespace</span><br><span class="line"> </span><br><span class="line"># 设置为true以确保文件在保存时以换行符结尾</span><br><span class="line"># 如果设置为true，则文件最后一行也会确保以换行符结尾，会强制换行到下一行  ***</span><br><span class="line">insert_final_newline</span><br></pre></td></tr></table></figure>
<h2 id="通配方式"><a href="#通配方式" class="headerlink" title="通配方式"></a>通配方式</h2><h5 id=""><a href="#" class="headerlink" title="*"></a>*</h5><p>任何字符串，路径分隔符 (  / ) 除外</p>
<h5 id="-1"><a href="#-1" class="headerlink" title="**"></a>**</h5><p>任何字符串</p>
<h5 id="-2"><a href="#-2" class="headerlink" title="?"></a>?</h5><p>任何单个字符，路径分隔符  ( / ) 除外</p>
<h5 id="name"><a href="#name" class="headerlink" title="[name]"></a>[name]</h5><p>匹配名称中的任何单个字符</p>
<h5 id="name-1"><a href="#name-1" class="headerlink" title="[!name]"></a>[!name]</h5><p>匹配名称中没有的任何单个字符</p>
<h5 id="s1-s2-s3"><a href="#s1-s2-s3" class="headerlink" title="{s1,s2,s3}"></a>{s1,s2,s3}</h5><p>匹配任何给定的字符串（以逗号分隔，可以嵌套）</p>
<h5 id="num1-num2"><a href="#num1-num2" class="headerlink" title="{num1..num2}"></a>{num1..num2}</h5><p>num1 和之间的任何整数 num2，其中 num1 和 num2 可以是正数或负数</p>
<p>匹配到的不同的文件类型，可以定义不同的格式化属性。</p>
<p>特殊字符可以用反斜杠转义，这样它们就不会被解释为通配符模式。</p>
]]></content>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 饥荒服务器搭建教程</title>
    <url>/2022/09/16/Ubuntu-%E9%A5%A5%E8%8D%92%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Ubuntu-饥荒服务器搭建教程"><a href="#Ubuntu-饥荒服务器搭建教程" class="headerlink" title="Ubuntu 饥荒服务器搭建教程"></a>Ubuntu 饥荒服务器搭建教程</h1><p>服务器： ubuntu-18.04-amd64-20220507111916</p>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libstdc++6:i386 libgcc1:i386 libcurl4-gnutls-dev:i386</span><br></pre></td></tr></table></figure>
<h2 id="安装-steamCMD"><a href="#安装-steamCMD" class="headerlink" title="安装 steamCMD"></a>安装 steamCMD</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/steamcmd/</span><br><span class="line">cd ~/steamcmd/</span><br><span class="line">wget "https://steamcdn-a.akamaihd.net/client/installer/steamcmd_linux.tar.gz"</span><br><span class="line">tar -xvzf steamcmd_linux.tar.gz</span><br></pre></td></tr></table></figure>
<h2 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h2><p><a href="https://forums.kleientertainment.com/forums/topic/64441-dedicated-server-quick-setup-guide-linux" target="_blank" rel="noopener">依照官网教程注册 Klei 账号，注册服务器</a></p>
<p>下载 MyDediServer/ 文件夹</p>
<p>MyDediServer/ 放入 ~/.klei/DoNotStarveTogether/ 路径</p>
<h2 id="设置入口脚本"><a href="#设置入口脚本" class="headerlink" title="设置入口脚本"></a>设置入口脚本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ~/run_dedicated_servers.sh</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">steamcmd_dir="$HOME/steamcmd"</span><br><span class="line">install_dir="$HOME/dontstarvetogether_dedicated_server"</span><br><span class="line">cluster_name="MyDediServer"</span><br><span class="line">dontstarve_dir="$HOME/.klei/DoNotStarveTogether"</span><br><span class="line"></span><br><span class="line">function fail()</span><br><span class="line">&#123;</span><br><span class="line">	echo Error: "$@" &gt;&amp;2</span><br><span class="line">	exit 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function check_for_file()</span><br><span class="line">&#123;</span><br><span class="line">	if [ ! -e "$1" ]; then</span><br><span class="line">		fail "Missing file: $1"</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cd "$steamcmd_dir" || fail "Missing $steamcmd_dir directory!"</span><br><span class="line"></span><br><span class="line">check_for_file "steamcmd.sh"</span><br><span class="line">check_for_file "$dontstarve_dir/$cluster_name/cluster.ini"</span><br><span class="line">check_for_file "$dontstarve_dir/$cluster_name/cluster_token.txt"</span><br><span class="line">check_for_file "$dontstarve_dir/$cluster_name/Master/server.ini"</span><br><span class="line">check_for_file "$dontstarve_dir/$cluster_name/Caves/server.ini"</span><br><span class="line"></span><br><span class="line">./steamcmd.sh +force_install_dir "$install_dir" +login anonymous +app_update 343050 validate +quit</span><br><span class="line"></span><br><span class="line">check_for_file "$install_dir/bin64"</span><br><span class="line"></span><br><span class="line">cd "$install_dir/bin64" || fail</span><br><span class="line"></span><br><span class="line">run_shared=(./dontstarve_dedicated_server_nullrenderer_x64)</span><br><span class="line">run_shared+=(-console)</span><br><span class="line">run_shared+=(-cluster "$cluster_name")</span><br><span class="line">run_shared+=(-monitor_parent_process $$)</span><br><span class="line"></span><br><span class="line">"$&#123;run_shared[@]&#125;" -shard Caves  | sed 's/^/Caves:  /' &amp;</span><br><span class="line">"$&#123;run_shared[@]&#125;" -shard Master | sed 's/^/Master: /'</span><br></pre></td></tr></table></figure>
<h3 id="脚本权限"><a href="#脚本权限" class="headerlink" title="脚本权限"></a>脚本权限</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod u+x ~/run_dedicated_servers.sh</span><br></pre></td></tr></table></figure>
<h2 id="运行入口脚本"><a href="#运行入口脚本" class="headerlink" title="运行入口脚本"></a>运行入口脚本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">~/run_dedicated_servers.sh</span><br></pre></td></tr></table></figure>
<h2 id="可能的问题"><a href="#可能的问题" class="headerlink" title="可能的问题"></a>可能的问题</h2><h3 id="库缺失"><a href="#库缺失" class="headerlink" title="库缺失"></a>库缺失</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./dontstarve_dedicated_server_nullrenderer: error while loading shared libraries: libcurl-gnutls.so.4: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install libcurl4-gnutls-dev</span><br><span class="line">dpkg --add-architecture i386</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 Ubuntu R 语言环境的 Laravel 服务器部署</title>
    <url>/2022/07/26/%E5%9F%BA%E4%BA%8E%20Ubuntu%20R%20%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83%E7%9A%84%20Laravel%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>服务器：百度云，2核/4GB内存/80GB磁盘/6Mbps带宽/Ubuntu ( ubuntu-20.04-amd64-20220507112023 ) </p>
<p>php: ^8.0</p>
<p>Laravel：^7.0.1</p>
<h2 id="操作系统选择"><a href="#操作系统选择" class="headerlink" title="操作系统选择"></a>操作系统选择</h2><p>Debian，Centos 在 R 语言的部署上各有问题，选择 Ubuntu ( ubuntu-20.04-amd64-20220507112023 ) </p>
<h2 id="一-R-语言安装"><a href="#一-R-语言安装" class="headerlink" title="一. R 语言安装"></a>一. R 语言安装</h2><p><a href="https://cran.r-project.org/bin/linux/ubuntu/" target="_blank" rel="noopener">官方文档</a></p>
<h3 id="1-获取最新版本的-R-语言（-4-）"><a href="#1-获取最新版本的-R-语言（-4-）" class="headerlink" title="1. 获取最新版本的 R 语言（^4.*）"></a>1. 获取最新版本的 R 语言（^4.*）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 检查更新</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt update -qq</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 dirmngr - 软件证书的管理工具</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install --no-install-recommends software-properties-common dirmngr</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> add the signing key (by Michael Rutter) <span class="keyword">for</span> these repos</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> To verify key, run gpg --show-keys /etc/apt/trusted.gpg.d/cran_ubuntu_key.asc </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Fingerprint: E298A3A825C0D65DFD57CBB651716619E084DAB9</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wget -qO- https://cloud.r-project.org/bin/linux/ubuntu/marutter_pubkey.asc | sudo tee -a /etc/apt/trusted.gpg.d/cran_ubuntu_key.asc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> add the R 4.0 repo from CRAN -- adjust <span class="string">'focal'</span> to <span class="string">'groovy'</span> or <span class="string">'bionic'</span> as needed</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo add-apt-repository <span class="string">"deb https://cloud.r-project.org/bin/linux/ubuntu <span class="variable">$(lsb_release -cs)</span>-cran40/"</span></span></span><br></pre></td></tr></table></figure>
<h3 id="2-安装-R-语言"><a href="#2-安装-R-语言" class="headerlink" title="2. 安装 R 语言"></a>2. 安装 R 语言</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装 R 语言</span><br><span class="line">$ sudo apt install --no-install-recommends r-base</span><br></pre></td></tr></table></figure>
<h3 id="3-测试-R-语言"><a href="#3-测试-R-语言" class="headerlink" title="3. 测试 R 语言"></a>3. 测试 R 语言</h3><p>在此页面应能看到 R 的版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打开 R 交互式窗口</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> R</span></span><br></pre></td></tr></table></figure>
<h3 id="4-安装需要的依赖包"><a href="#4-安装需要的依赖包" class="headerlink" title="4. 安装需要的依赖包"></a>4. 安装需要的依赖包</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打开 R 交互式窗口</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> R</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># R 的交互命令行</span></span><br><span class="line">&gt; install.packages(<span class="string">"dependencesA"</span>)</span><br><span class="line">&gt; install.packages(<span class="string">"dependencesB"</span>)</span><br><span class="line">&gt; install.packages(<span class="string">"dependencesC"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="二-安装宝塔"><a href="#二-安装宝塔" class="headerlink" title="二. 安装宝塔"></a>二. 安装宝塔</h2><p><a href="https://www.bt.cn/new/index.html" target="_blank" rel="noopener">宝塔</a>是一个较为简单快捷的部署工具</p>
<h3 id="1-选择在线安装"><a href="#1-选择在线安装" class="headerlink" title="1. 选择在线安装"></a>1. 选择在线安装</h3><p>记住给的服务器地址和登陆密码！</p>
<p><a href="https://imgtu.com/i/jzvfxg" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2022/07/26/jzvfxg.png" alt="jzvfxg.png"></a></p>
<h3 id="2-进入管理页面"><a href="#2-进入管理页面" class="headerlink" title="2.  进入管理页面"></a>2.  进入管理页面</h3><p>(1) 选择 [软件商店]，一键安装 nginx 1.21.0，php-8</p>
<p>(2) 选择 [网站]，添加站点，域名为网站域名</p>
<p>(3) 选择 [软件商店]，php 设置，安装扩展，安装 fileinfo 插件，若报错 <code>Cannot find **auto**conf. Please check your autoconf installation and the $PHP_AUTOCONF environment variable. Then, rerun this script</code></p>
<p>则运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> apt-get install autoconf -y</span></span><br></pre></td></tr></table></figure>
<p>以安装</p>
<p>(4) 选择 [软件商店]，php 设置，删除以下被禁用的函数：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">putenv</span><br><span class="line">pcntl_signal</span><br><span class="line">proc_open</span><br><span class="line">exec</span><br></pre></td></tr></table></figure>
<h2 id="三-部署项目代码"><a href="#三-部署项目代码" class="headerlink" title="三. 部署项目代码"></a>三. 部署项目代码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入目录，参数应与域名相符</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /www/wwwroot/siteRootPath</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">clone</span> 项目</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/Squ1rrel-K/getLCAI_web.git</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> getLCAI_web</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> composer install</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 建立 .env 文件，生成密匙</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> php -r <span class="string">"file_exists('.env') || copy('.env.example', '.env');"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> php artisan key:generate --ansi</span></span><br></pre></td></tr></table></figure>
<p>进入宝塔运维主页，选择 [网站]，添加站点，域名为网站域名，修改网站目录的运行目录为 /public </p>
<h2 id="四-管理权限问题"><a href="#四-管理权限问题" class="headerlink" title="四. 管理权限问题"></a>四. 管理权限问题</h2><p>普通文件夹权限为 755 即可</p>
<p>storage，resources，scripts 权限必须至少 775</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /www/wwwroot/siteRootPath/getLCAI_web</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod -R 775 storage/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod -R 777 storage/logs/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod -R 775 resources/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod -R 775 scripts/</span></span><br></pre></td></tr></table></figure>
<h2 id="五-优化项目部署"><a href="#五-优化项目部署" class="headerlink" title="五. 优化项目部署"></a>五. 优化项目部署</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /www/wwwroot/siteRootPath/getLCAI_web</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> php artisan config:cache <span class="comment"># 生成配置缓存</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> php artisan route:cache <span class="comment"># 生成路由缓存</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm run production <span class="comment"># 运行 npm 产品环境</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>server</category>
        <category>tutorial</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>健身笔记</title>
    <url>/2021/07/25/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="分化训练"><a href="#分化训练" class="headerlink" title="分化训练"></a>分化训练</h1><h1 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h1><h1 id="最高原则"><a href="#最高原则" class="headerlink" title="最高原则"></a>最高原则</h1><p>健身先健脑</p>
<p>科学健身</p>
<p>避免受伤</p>
<h1 id="分化训练-3-分化"><a href="#分化训练-3-分化" class="headerlink" title="分化训练 - 3 分化"></a>分化训练 - 3 分化</h1><p>胸 + 三头</p>
<p>背 + 二头</p>
<p>肩膀</p>
<p>平常多踢球，增强臀部，腿部力量</p>
<h1 id="胸"><a href="#胸" class="headerlink" title="胸"></a>胸</h1><h2 id="哑铃杠铃卧推"><a href="#哑铃杠铃卧推" class="headerlink" title="哑铃杠铃卧推"></a>哑铃杠铃卧推</h2><p>10 kg，12个一组，4组</p>
<h2 id="上斜杠铃哑铃卧推"><a href="#上斜杠铃哑铃卧推" class="headerlink" title="上斜杠铃哑铃卧推"></a>上斜杠铃哑铃卧推</h2><h2 id="单侧大重量绳索架胸"><a href="#单侧大重量绳索架胸" class="headerlink" title="单侧大重量绳索架胸"></a>单侧大重量绳索架胸</h2><h2 id="俯卧撑"><a href="#俯卧撑" class="headerlink" title="俯卧撑"></a>俯卧撑</h2><h2 id="臂屈伸"><a href="#臂屈伸" class="headerlink" title="臂屈伸"></a>臂屈伸</h2>]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 常用命令</title>
    <url>/2021/03/04/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>Google软件测试之道读书笔记</title>
    <url>/2021/03/02/Google%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B9%8B%E9%81%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Google软件测试之道-读书笔记"><a href="#Google软件测试之道-读书笔记" class="headerlink" title="Google软件测试之道 读书笔记"></a>Google软件测试之道 读书笔记</h1><p>测试方法不当，会扼杀一个本有机会成功的公司，拖慢产品速度 </p>
<p>我们需要把开发跟测试融合为一个整体</p>
<p>有时候测试跟开发互相交织，有时又完全分离</p>
<p>质量不等于测试，质量更像是一种预防行为，而不是检测</p>
<p>开发人员要对自己写的代码负责，比专职测试人员更适合做测试工作</p>
<p>Google并没有使用代码测试、集成测试、系统测试这些命名方式，而是使用小型测试、中型测试、大型测试这样的称谓，着重强调测试的范畴规模而非形式。</p>
]]></content>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer JZ模板</title>
    <url>/2021/03/01/%E5%89%91%E6%8C%87offer-JZ%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="JZ"><a href="#JZ" class="headerlink" title="JZ"></a>JZ</h1><p><a href="">原题链接</a></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>$T:O()$</p>
<p>$S:O()$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer JZ10</title>
    <url>/2021/03/01/%E5%89%91%E6%8C%87offer-JZ10/</url>
    <content><![CDATA[<h1 id="JZ10"><a href="#JZ10" class="headerlink" title="JZ10"></a>JZ10</h1><p><a href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6" target="_blank" rel="noopener">原题链接</a></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>还是 dp 问题</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>推出状态转移方程</p>
<p>$T:O(n)$</p>
<p>$S:O(n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[number + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (number == <span class="number">1</span>)<span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (number == <span class="number">2</span>)<span class="keyword">return</span> dp[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= number; i++) dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> dp[number];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer JZ9</title>
    <url>/2021/03/01/%E5%89%91%E6%8C%87offer-JZ9/</url>
    <content><![CDATA[<h1 id="JZ9"><a href="#JZ9" class="headerlink" title="JZ9"></a>JZ9</h1><p><a href="owcoder.com/practice/22243d016f6b47f2a6928b4313c85387">原题链接</a></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>dp 题，写出状态转移方程即可</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>$f(n) = \sum\limits_{i=1}^{n-1}f(i)$</p>
<p>$T:O(n)$</p>
<p>$S:O(n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[number + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= number; i++) &#123;</span><br><span class="line">            dp[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                dp[i] += dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[number];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer JZ8</title>
    <url>/2021/03/01/%E5%89%91%E6%8C%87offer-JZ8/</url>
    <content><![CDATA[<h1 id="JZ8"><a href="#JZ8" class="headerlink" title="JZ8"></a>JZ8</h1><p><a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4" target="_blank" rel="noopener">原题链接</a></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>dp 题，写出状态转移方程即可</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>$f[n] = f[n-2] + f[n-1]$</p>
<p>$T:O(n)$</p>
<p>$S:O(n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[number + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (number == <span class="number">1</span>) <span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= number; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">2</span>] + dp[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[number];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer JZ7</title>
    <url>/2021/03/01/%E5%89%91%E6%8C%87offer-JZ7/</url>
    <content><![CDATA[<h1 id="JZ7"><a href="#JZ7" class="headerlink" title="JZ7"></a>JZ7</h1><p><a href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3" target="_blank" rel="noopener">原题链接</a></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。</p>
<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>dp 的基础，斐波那契的路径存储，以利用剪枝</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>经典中的经典，dp 一下路径即可</p>
<p>$T:O(n)$</p>
<p>$S:O(n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[number + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (number == <span class="number">1</span>)<span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (number == <span class="number">2</span>)<span class="keyword">return</span> dp[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= number; i++) dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> dp[number];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer JZ6</title>
    <url>/2021/03/01/%E5%89%91%E6%8C%87offer-JZ6/</url>
    <content><![CDATA[<h1 id="JZ6"><a href="#JZ6" class="headerlink" title="JZ6"></a>JZ6</h1><p><a href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba" target="_blank" rel="noopener">原题链接</a></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>看似简单，实则考虑数组查找的优化问题</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="傻乎乎遍历-2分"><a href="#傻乎乎遍历-2分" class="headerlink" title="傻乎乎遍历 2分"></a>傻乎乎遍历 2分</h3><p>$T:O(\frac{n}{2} )$</p>
<p>$S:O(1)$</p>
<p>要不就不转，第一个元素是最小，要不就转，那突然下落的地方肯定是最小元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rotateArray.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">min</span> = rotateArray[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rotateArray.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rotateArray[i] &gt; rotateArray[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">min</span> = rotateArray[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二分法-5分"><a href="#二分法-5分" class="headerlink" title="二分法 5分"></a>二分法 5分</h3>]]></content>
      <categories>
        <category>刷题</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer JZ5</title>
    <url>/2021/03/01/%E5%89%91%E6%8C%87offer-JZ5/</url>
    <content><![CDATA[<h1 id="JZ5"><a href="#JZ5" class="headerlink" title="JZ5"></a>JZ5</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>栈模拟队列，两个栈捯饬一下即可</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>保持 stack2 在所有操作后为空，只在 pop 时借用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> top=<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//转移至栈2</span></span><br><span class="line">        <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">            stack2.push(stack1.top());</span><br><span class="line">            stack1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//栈1不空，则栈2必不空</span></span><br><span class="line">        <span class="keyword">if</span> (!stack2.empty()) &#123;</span><br><span class="line">            top = stack2.top();</span><br><span class="line">            stack2.pop();</span><br><span class="line">            <span class="keyword">while</span> (!stack2.empty()) &#123;</span><br><span class="line">                stack1.push(stack2.top());</span><br><span class="line">                stack2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> top;</span><br><span class="line">            <span class="comment">//栈1空</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
        <category>栈队列</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer JZ4</title>
    <url>/2021/03/01/%E5%89%91%E6%8C%87offer-JZ4/</url>
    <content><![CDATA[<h1 id="JZ4"><a href="#JZ4" class="headerlink" title="JZ4"></a>JZ4</h1><p><a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6" target="_blank" rel="noopener">原题链接</a></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>中序+其他序造树，分随机存储（数组），顺序存储（链表）两种，找 root 两边 dfs 递归即可，PAT 送分题</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="常规题"><a href="#常规题" class="headerlink" title="常规题"></a>常规题</h3><p>$T:O(n)$</p>
<p>$S:O(n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildTree(pre, vin, <span class="number">0</span>, pre.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">0</span>, vin.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode *<span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;pre, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vin, <span class="keyword">int</span> preL, <span class="keyword">int</span> preR, <span class="keyword">int</span> inL, <span class="keyword">int</span> inR)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//返回</span></span><br><span class="line">        <span class="keyword">if</span> (preL &gt; preR) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//新根</span></span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(pre[preL]);</span><br><span class="line">        <span class="comment">//找 vin 中的根</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = inL; i &lt;= inR; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre[preL] == vin[i]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归子树</span></span><br><span class="line">        <span class="keyword">int</span> numLeft = i - inL;</span><br><span class="line">        root-&gt;left = buildTree(pre, vin, preL + <span class="number">1</span>, preL + numLeft, inL, i - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = buildTree(pre, vin, preL + numLeft + <span class="number">1</span>, preR, i + <span class="number">1</span>, inR);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer JZ3</title>
    <url>/2021/03/01/%E5%89%91%E6%8C%87offer-JZ3/</url>
    <content><![CDATA[<h1 id="JZ3"><a href="#JZ3" class="headerlink" title="JZ3"></a>JZ3</h1><p><a href="nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035">原题链接</a></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p>
<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>链表翻转，可提出可直接模拟</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="提出法（包括栈模拟，数组翻转，反向迭代器）"><a href="#提出法（包括栈模拟，数组翻转，反向迭代器）" class="headerlink" title="提出法（包括栈模拟，数组翻转，反向迭代器）"></a>提出法（包括栈模拟，数组翻转，反向迭代器）</h3><p>数据提出来扔 vector 里，在输出即可，不是真正的翻转链表，仅数据反向输出</p>
<p>$T:O(n)$</p>
<p>$S:O(n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  struct ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        struct ListNode *next;</span></span><br><span class="line"><span class="comment">*        ListNode(int x) :</span></span><br><span class="line"><span class="comment">*              val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*  &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">list</span>.push_back(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(<span class="built_in">list</span>.<span class="built_in">begin</span>(), <span class="built_in">list</span>.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="模拟法"><a href="#模拟法" class="headerlink" title="模拟法"></a>模拟法</h3><p>真实模拟链的变换，若题目需要输出 list 而非 vector 则此方法为好方法</p>
]]></content>
      <categories>
        <category>刷题</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer JZ2</title>
    <url>/2021/03/01/%E5%89%91%E6%8C%87offer-JZ2/</url>
    <content><![CDATA[<h1 id="JZ2"><a href="#JZ2" class="headerlink" title="JZ2"></a>JZ2</h1><p><a href="https://www.nowcoder.com/practice/0e26e5551f2b489b9f58bc83aa4b6c68" target="_blank" rel="noopener">原题链接</a></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>字符串替换，STL 简单处理</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="stl-string-replace"><a href="#stl-string-replace" class="headerlink" title="stl string.replace()"></a>stl string.replace()</h3><p>$T:O(n)$</p>
<p>$S:O(1)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param s string字符串 </span></span><br><span class="line"><span class="comment">     * @return string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">replaceSpace</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(s[i]==<span class="string">' '</span>) s.replace(i,<span class="number">1</span>,<span class="string">"%20"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer JZ1</title>
    <url>/2021/03/01/%E5%89%91%E6%8C%87offer-JZ1/</url>
    <content><![CDATA[<h1 id="JZ1"><a href="#JZ1" class="headerlink" title="JZ1"></a>JZ1</h1><p><a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e" target="_blank" rel="noopener">原题链接</a></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>数组遍历与优化，元素有序易想到二分法，观察法不易想到</p>
<h2 id="思路-M行N列"><a href="#思路-M行N列" class="headerlink" title="思路 M行N列"></a>思路 M行N列</h2><h3 id="暴力枚举-1分"><a href="#暴力枚举-1分" class="headerlink" title="暴力枚举 1分"></a>暴力枚举 1分</h3><p>一个个查，不好，浪费了两个方向有序的条件</p>
<p>$T: O(mn)$</p>
<p>$S: O(1)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span> &lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//空数组</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>.<span class="built_in">size</span>() == <span class="number">0</span> || <span class="built_in">array</span>[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">array</span>[<span class="number">0</span>].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (target == <span class="built_in">array</span>[i][j]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="行二分-2分"><a href="#行二分-2分" class="headerlink" title="行二分 2分"></a>行二分 2分</h3><p>一行行查，每行的数使用二分法</p>
<p>$T: O(mlogn)$</p>
<p>$S:O(1)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span> &lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//空数组</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>.<span class="built_in">size</span>() == <span class="number">0</span> || <span class="built_in">array</span>[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//行遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="built_in">array</span>[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//每行的数二分</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (target == <span class="built_in">array</span>[i][mid]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; <span class="built_in">array</span>[i][mid]) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; <span class="built_in">array</span>[i][mid]) &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="观察法（副对角线顶点法）5分"><a href="#观察法（副对角线顶点法）5分" class="headerlink" title="观察法（副对角线顶点法）5分"></a>观察法（副对角线顶点法）5分</h3><p>妙啊！</p>
<p>右上角（左下角）的节点一定是该行最大，该列最小的，比较后按照大小关系移动即可</p>
<p>$T:O(n)$, $n=max(M,N)$</p>
<p>$S:O(1)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span> &lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//空数组</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>.<span class="built_in">size</span>() == <span class="number">0</span> || <span class="built_in">array</span>[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="built_in">array</span>[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>, val;</span><br><span class="line">        <span class="comment">//元素在数组范围内移动</span></span><br><span class="line">        <span class="keyword">while</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; <span class="built_in">array</span>.<span class="built_in">size</span>() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; <span class="built_in">array</span>[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">            val = <span class="built_in">array</span>[x][y];</span><br><span class="line">            <span class="keyword">if</span> (target == val) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//大于，下移</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; val) x++;</span><br><span class="line">            <span class="comment">//小于，左移</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; val) y--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>又是一个小细节</title>
    <url>/2021/02/08/%E5%8F%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%BB%86%E8%8A%82/</url>
    <content><![CDATA[<h1 id="Clion-ctrl-alt-L-格式化代码无效"><a href="#Clion-ctrl-alt-L-格式化代码无效" class="headerlink" title="Clion ctrl+alt+L 格式化代码无效"></a>Clion ctrl+alt+L 格式化代码无效</h1><p>网易云快捷键占用了</p>
]]></content>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>基础排序算法</title>
    <url>/2021/02/07/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="基础排序算法"><a href="#基础排序算法" class="headerlink" title="基础排序算法"></a>基础排序算法</h1><h2 id="STL-sort-方法"><a href="#STL-sort-方法" class="headerlink" title="STL - sort 方法"></a>STL - sort 方法</h2><p>源码实现：快排结合插排，堆排</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.xxx &lt; b.xxx;</span><br><span class="line">&#125;</span><br><span class="line">sort(a, a + maxn, cmp) <span class="comment">//如果a是2维数组，首地址为a[0]，一定要注意</span></span><br></pre></td></tr></table></figure>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
      <categories>
        <category>读书笔记</category>
        <category>数据结构</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>肉类与香料</title>
    <url>/2021/02/07/%E8%82%89%E7%B1%BB%E4%B8%8E%E9%A6%99%E6%96%99/</url>
    <content><![CDATA[<h1 id="肉类与香料"><a href="#肉类与香料" class="headerlink" title="肉类与香料"></a>肉类与香料</h1><p>在肉类的处理中，无论是烹炒还是烧菜，香料的合理运用可以去膻增香，事半功倍</p>
<h1 id="加料"><a href="#加料" class="headerlink" title="加料"></a>加料</h1><p>本质上香料属于中草药，药食同源，因此量不宜过大，否则喧宾夺主</p>
<p>味重少放，味清适量多放一点</p>
<p>香料3种，可以稍多一点，不宜超过8种</p>
<h1 id="猪肉"><a href="#猪肉" class="headerlink" title="猪肉"></a>猪肉</h1><p>猪肉喜大料桂皮，捏两粒花椒，几粒小茴香，一片香叶</p>
<h1 id="羊肉"><a href="#羊肉" class="headerlink" title="羊肉"></a>羊肉</h1><p>羊肉喜花椒，可以多放花椒，不喜大料桂皮，可以适量加香叶、小茴香、孜然</p>
<h1 id="牛肉"><a href="#牛肉" class="headerlink" title="牛肉"></a>牛肉</h1><p>牛肉喜大料，不喜花椒桂皮，一般用素菜炖，突出本身鲜香</p>
]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>Ps技巧</title>
    <url>/2021/02/07/Ps%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="Ps技巧"><a href="#Ps技巧" class="headerlink" title="Ps技巧"></a><strong>Ps技巧</strong></h1><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a><strong>快捷键</strong></h2><p><code>V</code> 移动工具</p>
<p>快速复制图层</p>
<p><code>Ctrl + J</code> 或者 <code>Alt</code> + 拖动</p>
<p>调整图层大小</p>
<p><code>Ctrl + T</code></p>
<h2 id="智能对象"><a href="#智能对象" class="headerlink" title="智能对象"></a>智能对象</h2><p>说白了就是图层 Class 化</p>
<p>资源扔到 class 里做工厂处理</p>
<p>oop 就是 nb，对象化之后的处理也是基于对象了</p>
<h1 id="栅格化"><a href="#栅格化" class="headerlink" title="栅格化"></a>栅格化</h1><p>说白了就是按像素划分图形，将一个向量图层位图化</p>
<p>参照 bootstrap 的 Grid system（栅格系统）</p>
]]></content>
      <tags>
        <tag>video</tag>
      </tags>
  </entry>
  <entry>
    <title>PR技巧</title>
    <url>/2021/01/17/PR%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="Pr技巧"><a href="#Pr技巧" class="headerlink" title="Pr技巧"></a>Pr技巧</h1><p>快捷键</p>
]]></content>
      <tags>
        <tag>video</tag>
      </tags>
  </entry>
  <entry>
    <title>新年第一篇</title>
    <url>/2021/01/12/%E6%96%B0%E5%B9%B4%E7%AC%AC%E4%B8%80%E7%AF%87/</url>
    <content><![CDATA[<h1 id="新年第一篇"><a href="#新年第一篇" class="headerlink" title="新年第一篇"></a>新年第一篇</h1><p>本来该去年12月27号考完研写的博客，拖到了现在，脑子很乱，借着键盘梳理一下</p>
<h2 id="考研二三事"><a href="#考研二三事" class="headerlink" title="考研二三事"></a>考研二三事</h2><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-A-1134</title>
    <url>/2020/08/28/PAT-A-1134/</url>
    <content><![CDATA[<h1 id="PAT-A-1134"><a href="#PAT-A-1134" class="headerlink" title="PAT-A-1134"></a>PAT-A-1134</h1><p>bad Code</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> v, e, k, qu,q;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10005</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cop[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;v, &amp;e);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v1, v2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;v1, &amp;v2);</span><br><span class="line">        edge[v1].push_back(v2);</span><br><span class="line">        edge[v2].push_back(v1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++) &#123;</span><br><span class="line">            cop[i] = edge[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;qu);</span><br><span class="line">        <span class="keyword">while</span>(qu--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">            <span class="comment">//每个顶点i来说，iq，qi 不为-1则变-1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cop[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                    <span class="comment">//i-&gt;q</span></span><br><span class="line">                    <span class="keyword">if</span> (cop[i][j] == q) &#123;</span><br><span class="line">                        cop[i][j] = <span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cop[q].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                    <span class="comment">//q-&gt;i</span></span><br><span class="line">                    <span class="keyword">if</span> (cop[q][j] == i) cop[q][j] = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it :cop[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (it != <span class="number">-1</span>) flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PAT</category>
        <category>PAT A</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>极限与计算</title>
    <url>/2020/07/29/%E6%9E%81%E9%99%90%E4%B8%8E%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h1 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h1><h2 id="核心工具"><a href="#核心工具" class="headerlink" title="核心工具"></a>核心工具</h2><p>定义法</p>
<p>无穷小比较 -&gt;等价无穷小</p>
<p>夹逼定理</p>
<p>单调有界</p>
<p>四则运算</p>
<p>洛必达</p>
<p>泰勒公式</p>
<p>积分和式</p>
<h2 id="极限存在讨论"><a href="#极限存在讨论" class="headerlink" title="极限存在讨论"></a>极限存在讨论</h2><p>夹逼定理</p>
<p>单调有界</p>
<h2 id="计算极限"><a href="#计算极限" class="headerlink" title="计算极限"></a>计算极限</h2><p>加减拆开前提：两个儿子极限<strong>都存在</strong></p>
<p>等价无穷小条件：<strong>乘除因子</strong>才能使用</p>
<p>洛必达条件：0 比 0 或 $\infty$  比 $\infty$ ，<strong>去心邻域可导</strong>，分母导不为 0 </p>
<p>泰勒公式条件：在 $x_0$ 存在 <strong>$n$ 阶导</strong></p>
<h3 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h3><p>加减和式勇敢试一试极限是否存在，是就直接求了</p>
<p>整个一个因式极限存在且不为 0，直接先求出来再说</p>
<p>不要憨憨疯狂洛必达，中间可以等价无穷小的要先化简</p>
<p>泰勒比等价无穷小精细，比洛必达条件更弱，因此泛用性更强</p>
<p>泰勒展开只针对项，比等价无穷小牛逼</p>
<p>0 比 0 或 $\infty$  比 $\infty$ 形式更容易处理，考虑各种通分</p>
<h2 id="做题技巧"><a href="#做题技巧" class="headerlink" title="做题技巧"></a>做题技巧</h2><p>选择题合适时直接带入答案，节省时间</p>
<p>带根号项的长因式，多考虑通分，凑出来分子正好消掉根号</p>
<p>$(x+b)^{cx+d}$  等类似情况，考虑化成 $e^{sth.}$ 搞，再求 $sth.$ 极限就成</p>
<p>告诉了未知函数的极限存在，往往有隐含信息，如可以泰勒，洛必达</p>
<p>求参数题考虑无穷小的定义</p>
<p>已知极限求极限，先尝试凑得式，直接求 $f(x)$ 往往就会累死</p>
<p>三角函数突兀塞在式子里，多半要泰勒</p>
<p>函数数列混合型，不是消项就是每项凑合理因式化简</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT模板</title>
    <url>/2020/07/28/PAT%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="PAT-A-xxxx"><a href="#PAT-A-xxxx" class="headerlink" title="PAT-A-xxxx"></a>PAT-A-xxxx</h1><p><a href="https://github.com/Squ1rrel-K/PAT-A-CPP" target="_blank" rel="noopener">所有甲级题全解</a></p>
<p><a href="">原题链接</a></p>
<h2 id="生僻词汇："><a href="#生僻词汇：" class="headerlink" title="生僻词汇："></a>生僻词汇：</h2><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>PAT-A-1005</title>
    <url>/2020/07/28/PAT-A-1005/</url>
    <content><![CDATA[<h1 id="PAT-A-1005"><a href="#PAT-A-1005" class="headerlink" title="PAT-A-1005"></a>PAT-A-1005</h1><p><a href="https://github.com/Squ1rrel-K/PAT-A-C-Cpp" target="_blank" rel="noopener">所有甲级题全解</a></p>
<p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805519074574336" target="_blank" rel="noopener">原题链接</a></p>
<h2 id="生僻词汇："><a href="#生僻词汇：" class="headerlink" title="生僻词汇："></a>生僻词汇：</h2><p>consecutive 连续的</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个数 A，求各数位之和，格式化输出</p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>整型范围判定</p>
<p>C/C++ 字符数组与字符串选择使用</p>
<p>ASCII 转整型</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>$N$ 的范围是 $10^{100}$ ，显然远超 long long (约 $10^{18}$)，考虑使用 <code>string</code> 接 ASCII 转数字</p>
<p>注意不要打错字，建议检查，或者直接复制粘贴</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> num;</span><br><span class="line"><span class="built_in">string</span> str[<span class="number">10</span>] = &#123;<span class="string">"zero"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>, <span class="string">"five"</span>, <span class="string">"six"</span>, <span class="string">"seven"</span>, <span class="string">"eight"</span>, <span class="string">"nine"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//输入</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//各数位之和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length(); i++) &#123;</span><br><span class="line">        sum += num[i] - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转字符串</span></span><br><span class="line">    <span class="built_in">string</span> res = to_string(sum);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//格式化输出，输出尾部不应有0</span></span><br><span class="line">    <span class="keyword">while</span> (i != res.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != res.length() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; str[res[i] - <span class="string">'0'</span>] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; str[res[i] - <span class="string">'0'</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PAT</category>
        <category>PAT A</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>免费博客制作教程</title>
    <url>/2020/07/28/%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="免费博客制作教程"><a href="#免费博客制作教程" class="headerlink" title="免费博客制作教程"></a>免费博客制作教程</h1><p><strong>本篇教程使用 Git + Github Page + hexo</strong>，服务器与框架均免费使用，可搭配域名。</p>
<h2 id="获取-github-page"><a href="#获取-github-page" class="headerlink" title="获取 github page"></a>获取 github page</h2><p>参考 <a href="https://pages.github.com/" target="_blank" rel="noopener">官方教程</a></p>
<p>申请仓库，注意仓库命名有硬性要求，一般为 username.github.io</p>
<p>如 <a href="http://squ1rrel.com/">Squ1rrel-K.github.io</a></p>
<h2 id="Git-下安装-hexo"><a href="#Git-下安装-hexo" class="headerlink" title="Git 下安装 hexo"></a>Git 下安装 hexo</h2><p>参考 <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官方文档</a></p>
<p>新建 username.github.io 文件夹</p>
<p><code>hexo init</code></p>
<p><code>npm install</code></p>
<h2 id="安装主题-theme"><a href="#安装主题-theme" class="headerlink" title="安装主题 theme"></a>安装主题 theme</h2><p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">官方主题区</a></p>
<p>找到适合自己的主题，按制作者要求处理即可</p>
<h2 id="写作与上传"><a href="#写作与上传" class="headerlink" title="写作与上传"></a>写作与上传</h2><p>新建文章 <code>hexo new post newTitle</code></p>
<p>进入 md 软件写作</p>
<p>渲染上传 <code>hexo d -g</code></p>
<h3 id="其它常用命令见官方文档"><a href="#其它常用命令见官方文档" class="headerlink" title="其它常用命令见官方文档"></a>其它常用命令见<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官方文档</a></h3>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-A-1004</title>
    <url>/2020/07/27/PATA1004/</url>
    <content><![CDATA[<h1 id="PAT-A-1004"><a href="#PAT-A-1004" class="headerlink" title="PAT-A-1004"></a>PAT-A-1004</h1><p><a href="https://github.com/Squ1rrel-K/PAT-A-C-Cpp" target="_blank" rel="noopener">所有甲级题全解</a></p>
<p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805521431773184" target="_blank" rel="noopener">原题链接</a></p>
<h2 id="生僻词汇"><a href="#生僻词汇" class="headerlink" title="生僻词汇"></a>生僻词汇</h2><p>hierarchy 层级</p>
<p>pedigree 家谱</p>
]]></content>
      <categories>
        <category>PAT</category>
        <category>PAT A</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-A-1003</title>
    <url>/2020/07/27/PATA1003/</url>
    <content><![CDATA[<h1 id="PAT-A-1003"><a href="#PAT-A-1003" class="headerlink" title="PAT-A-1003"></a>PAT-A-1003</h1><p><a href="https://github.com/Squ1rrel-K/PAT-A-C-Cpp" target="_blank" rel="noopener">所有甲级题全解</a></p>
<p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376" target="_blank" rel="noopener">原题链接</a></p>
<h2 id="生僻词汇"><a href="#生僻词汇" class="headerlink" title="生僻词汇"></a>生僻词汇</h2><p>scattered 分散的</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>你是个救援队头子，要从 A 到 B 点去救人，路途城市的人手可以捎上，求最短路径数量，跟最短路情况下最多救援队人数</p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>图的最短路径问题</p>
<p>多路径的第二权计算</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>非负权最短路显然用 Dijkstra 算法</p>
<p>多解用 <code>vector</code> 储存</p>
<p>计算比较第二权，即点权：人手</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">501</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, c1, c2, p1, p2, l, minDis = INF, maxPeo = <span class="number">0</span>, numOfDis = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> G[maxN][maxN], w[maxN], d[maxN];</span><br><span class="line"><span class="keyword">bool</span> vis[maxN] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre[maxN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dij</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//重置距离</span></span><br><span class="line">    <span class="built_in">fill</span>(d, d + maxN, INF);</span><br><span class="line">    d[c] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找最近的结点 n 次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">//找下一个最近的结点 u</span></span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, Min = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[v] == <span class="literal">false</span> &amp;&amp; d[v] &lt; Min) &#123;</span><br><span class="line">                u = v;</span><br><span class="line">                Min = d[v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//未找到最近结点 u</span></span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//访问 u</span></span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//尝试更新最短距离 u -&gt; v</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">            <span class="comment">//未访问，可访问</span></span><br><span class="line">            <span class="keyword">if</span> (vis[v] == <span class="literal">false</span> &amp;&amp; G[u][v] != INF) &#123;</span><br><span class="line">                <span class="comment">//路径相等</span></span><br><span class="line">                <span class="keyword">if</span> (d[u] + G[u][v] == d[v]) &#123;</span><br><span class="line">                    <span class="comment">//更新前驱结点</span></span><br><span class="line">                    pre[v].push_back(u);</span><br><span class="line">                &#125;</span><br><span class="line">                    <span class="comment">//路径更短，更新</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (d[u] + G[u][v] &lt; d[v]) &#123;</span><br><span class="line">                    d[v] = d[u] + G[u][v];</span><br><span class="line">                    pre[v].<span class="built_in">clear</span>();</span><br><span class="line">                    pre[v].push_back(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//边界条件</span></span><br><span class="line">    <span class="keyword">if</span> (v == c1) &#123;</span><br><span class="line">        tmp.push_back(v);</span><br><span class="line">        <span class="keyword">int</span> dis = <span class="number">0</span>, peo = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算路径 - 边权</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> u1 = tmp[i], u2 = tmp[i + <span class="number">1</span>];</span><br><span class="line">            dis += G[u1][u2];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算人数 - 点权</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = tmp[i];</span><br><span class="line">            peo += w[u];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//若为最短路径</span></span><br><span class="line">        <span class="keyword">if</span> (dis &lt; minDis) &#123;</span><br><span class="line">            numOfDis = <span class="number">1</span>;</span><br><span class="line">            minDis = dis;</span><br><span class="line">            maxPeo = peo;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//若最短路径不唯一</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (dis == minDis) &#123;</span><br><span class="line">            numOfDis++;</span><br><span class="line">            <span class="keyword">if</span> (peo &gt; maxPeo) maxPeo = peo;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归式</span></span><br><span class="line">    tmp.push_back(v);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pre[v].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        DFS(pre[v][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    tmp.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//输入</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;c1, &amp;c2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//点权赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭图</span></span><br><span class="line">    <span class="built_in">fill</span>(G[<span class="number">0</span>], G[<span class="number">0</span>] + maxN * maxN, INF);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//边权赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;p1, &amp;p2, &amp;l);</span><br><span class="line">        G[p1][p2] = G[p2][p1] = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Dij(c1);</span><br><span class="line">    DFS(c2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, numOfDis, maxPeo);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PAT</category>
        <category>PAT A</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-A-1002</title>
    <url>/2020/07/27/PATA1002/</url>
    <content><![CDATA[<h1 id="PAT-A-1002"><a href="#PAT-A-1002" class="headerlink" title="PAT-A-1002"></a>PAT-A-1002</h1><p><a href="https://github.com/Squ1rrel-K/PAT-A-C-Cpp" target="_blank" rel="noopener">所有甲级题全解</a></p>
<p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805526272000000" target="_blank" rel="noopener">原题链接</a></p>
<h2 id="生僻词汇"><a href="#生僻词汇" class="headerlink" title="生僻词汇"></a>生僻词汇</h2><p>Polynomial 多项式</p>
<p>exponent 指数</p>
<p>coefficient 系数</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给 A，B 两个多项式，求和</p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>变量类型合理选择</p>
<p>简单在线处理</p>
<p>数组下标模拟多项式指数</p>
<p>格式化输出</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>$N$ 上界只有 $10^3$，400ms 时限，两个数组直接暴力检索显然可以接受，但是在线处理可以保证时间复杂度始终在 $O(n)$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">double</span> arr[maxN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> k, n, cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> an;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环2次，输入2个多项式</span></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在线处理</span></span><br><span class="line">        <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%lf"</span>, &amp;n, &amp;an);</span><br><span class="line">            arr[n] += an;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非零项数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxN; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] != <span class="number">0</span>) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = maxN - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d %.1f"</span>, i, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PAT</category>
        <category>PAT A</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>晴神笔记</title>
    <url>/2020/07/27/%E6%99%B4%E7%A5%9E%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="C-C-算法竞赛常用技巧"><a href="#C-C-算法竞赛常用技巧" class="headerlink" title="C/C++ 算法竞赛常用技巧"></a>C/C++ 算法竞赛常用技巧</h1><h2 id="常用最大值"><a href="#常用最大值" class="headerlink" title="常用最大值"></a>常用最大值</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span></span><br></pre></td></tr></table></figure>
<p>INF + INF 还在 int 范围里</p>
<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p><strong>贪心</strong>应大胆尝试，无需证明</p>
<p>答案确定的问题可以直接<strong>打表</strong>，再输出，就 $O(1)$ 了</p>
<p>使用<strong>递推</strong>降低难度</p>
<h1 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h1><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>范围</th>
<th>大致范围</th>
<th>scanf()</th>
<th>printf()</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>int</strong></td>
<td>$2^{31} - 1$</td>
<td>$10^{9}$ ~ $10^{10}$</td>
<td>%d</td>
<td>%d</td>
</tr>
<tr>
<td><strong>long long</strong></td>
<td>$2^{63} - 1$</td>
<td>$10^{18}$ ~ $10^{19}$</td>
<td>%lld</td>
<td>%lld</td>
</tr>
</tbody>
</table>
</div>
<h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><p>浮点一般用 <strong>double</strong></p>
<p>精度 15 ~ 16位</p>
<p>输入: <code>scanf(&quot;%lf&quot;)</code></p>
<p>输出: <code>printf(&quot;%f&quot;)</code></p>
<p><code>printf(&quot;%.2f&quot;)</code></p>
<p><code>printf(&quot;%02d&quot;)</code></p>
<h3 id="浮点比较精度损失"><a href="#浮点比较精度损失" class="headerlink" title="浮点比较精度损失"></a>浮点比较精度损失</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span></span><br><span class="line">fab(a-b)&lt;eps <span class="comment">//满足条件</span></span><br></pre></td></tr></table></figure>
<h2 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h2><p>-128 ~ 127</p>
<p>小写字母比大写字母 <strong>ASCII</strong> 大 <strong>32</strong></p>
<p>输入: <code>scanf(&quot;%c&quot;)</code></p>
<p>输出: <code>printf(&quot;%c&quot;)</code></p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>简单可以用 <code>char[n]</code></p>
<p>输入: <code>scanf(&quot;%s&quot;,n)</code> <strong>无 &amp; 符号</strong></p>
<p>C <code>char str[]</code> 末尾需要 ‘\0’ 结束符，<code>scanf(&quot;%s&quot;)</code>, <code>gets()</code> 都自带</p>
<h4 id="string-h-只能接收字符数组"><a href="#string-h-只能接收字符数组" class="headerlink" title="string.h 只能接收字符数组"></a>string.h 只能接收字符数组</h4><p><code>strlen()</code>  长度</p>
<p><code>strcmp</code> 字典序，<strong>常用</strong></p>
<p><code>strcpy()</code> 复制</p>
<p><code>strcat()</code> 串接</p>
<h4 id="sscanf-sprintf"><a href="#sscanf-sprintf" class="headerlink" title="sscanf, sprintf"></a>sscanf, sprintf</h4><p><code>sscanf(str, &quot;%d&quot;, &amp;n)</code></p>
<p><code>sprintf(str,&quot;%d&quot;, n)</code></p>
<h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><p>复杂直接用 C++ 的 string</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>$10^6$ 级别以上需要定义在 <code>main()</code> 之外</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全赋值 o(n)</span></span><br><span class="line"><span class="keyword">int</span> arr[n] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> arr[n] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//memset 函数赋值 o(n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> arr[n];</span><br><span class="line"><span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span><br><span class="line"><span class="built_in">memset</span>(arr, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span><br><span class="line">    </span><br><span class="line"><span class="comment">//fill 函数赋值 o(n^2)</span></span><br></pre></td></tr></table></figure>
<h2 id="控制台输入，输出"><a href="#控制台输入，输出" class="headerlink" title="控制台输入，输出"></a>控制台输入，输出</h2><h2 id="C-2"><a href="#C-2" class="headerlink" title="C"></a>C</h2><h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf()"></a>scanf()</h3><p><code>scanf(&quot;%c&quot;)</code> 会读<code>&quot; &quot;</code> 和 <code>&quot;\n&quot;</code></p>
<h3 id="printf-格式化"><a href="#printf-格式化" class="headerlink" title="printf () 格式化"></a>printf () 格式化</h3><p><strong>%md</strong> 右对齐，空格补</p>
<p>%0md 右对齐，0 补</p>
<h3 id="getchar-putchar"><a href="#getchar-putchar" class="headerlink" title="getchar(), putchar()"></a>getchar(), putchar()</h3><p>获取（输出）单个字符，可获得<strong>空格</strong>，<strong>换行</strong></p>
<h3 id="gets-puts"><a href="#gets-puts" class="headerlink" title="gets(), puts()"></a>gets(), puts()</h3><p>读一行，以 “\n” 结尾</p>
<h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><h2 id="C-3"><a href="#C-3" class="headerlink" title="C"></a>C</h2><h3 id="math-h"><a href="#math-h" class="headerlink" title="math.h"></a>math.h</h3><p><code>fabs(double x)</code> 绝对值</p>
<p><code>floor(double x)</code> 向<strong>下</strong>取整</p>
<p><code>ceil(double x)</code> 向<strong>上</strong>取整</p>
<p><code>pow(double x, double y)</code> $x^y$</p>
<p><code>round(double x)</code> 四舍五入，输入也是 double 型，<strong>题目中说 round up to xxx 指的就是四舍五入</strong></p>
<h2 id="C-4"><a href="#C-4" class="headerlink" title="C++"></a>C++</h2><h3 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h3><p><code>max()</code> <code>min()</code> 浮点，整型均可以</p>
<p><code>abs(int x)</code>  绝对值</p>
<p><code>swap()</code> 交换</p>
<p><code>reverse(it, it2)</code>  范围元素反转</p>
<p><code>fill(arr, arr + n, x)</code>  范围赋值，注意时间复杂度 $O(n^2)$</p>
<h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单cmp</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体排序，可多级排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.id!=b.id) <span class="keyword">return</span> a.id &lt; b.id;<span class="comment">//一级排序</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.name &lt; b.name;<span class="comment">//二级排序</span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(<span class="built_in">begin</span>(), <span class="built_in">end</span>(),cmp)</span><br></pre></td></tr></table></figure>
<p><code>lower_bound(first, last, val)</code> 找第一个严格 &gt;= $val$，返回 it；</p>
<p><code>upper_bound(first, last, val)</code> 找第一个严格 &gt; $val$，返回 it；</p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="STL-sort函数使用"><a href="#STL-sort函数使用" class="headerlink" title="STL-sort函数使用"></a>STL-sort函数使用</h2><p>利用此函数可进行多级排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.xxx &lt; b.xxx;</span><br><span class="line">&#125;</span><br><span class="line">sort(a, a + maxn, cmp)</span><br></pre></td></tr></table></figure>
<h2 id="冒泡排序-bubble-sort"><a href="#冒泡排序-bubble-sort" class="headerlink" title="冒泡排序 bubble sort"></a>冒泡排序 bubble sort</h2><p>比较 $n-1$ 次，两两交换，把最大（小）值像泡泡一下送上去</p>
<h2 id="选择排序-Selection-Sort"><a href="#选择排序-Selection-Sort" class="headerlink" title="选择排序 Selection Sort"></a>选择排序 Selection Sort</h2><p>做 $n-1$ 次，每次从头到尾找最大数，给新序列的第一位，以此填补新序列</p>
<h2 id="插入排序-insert-sort"><a href="#插入排序-insert-sort" class="headerlink" title="插入排序 insert sort"></a>插入排序 insert sort</h2><p><code>a[0]</code> 有序，a[1] 插入，进而 a[2] 插入前序列，以此类推</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j - <span class="number">1</span>]) <span class="built_in">std</span>::swap(a[j], a[j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序-merge-sort"><a href="#归并排序-merge-sort" class="headerlink" title="归并排序 merge sort"></a>归并排序 merge sort</h2><h2 id="快速排序-Quicksort"><a href="#快速排序-Quicksort" class="headerlink" title="快速排序  Quicksort"></a>快速排序  Quicksort</h2><p>p139</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>p335</p>
<h1 id="进制处理"><a href="#进制处理" class="headerlink" title="进制处理"></a>进制处理</h1><p>p93</p>
<h1 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h1><p>散列<strong>核心思想</strong>是将一定有序的序列降维化</p>
<p>对应高等数学中的1对1映射</p>
<p>使一个整数可以尽可能唯一替代一个元素</p>
<h2 id="整数散列-时间复杂度降维"><a href="#整数散列-时间复杂度降维" class="headerlink" title="整数散列-时间复杂度降维"></a>整数散列-时间复杂度降维</h2><p>输入的数下标作为手段</p>
<p>统计该数性质</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> hashtable[maxn]</span><br><span class="line"><span class="comment">//此时hashtable[i] 可对应原某有序整数元素</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串散列-逻辑有序"><a href="#字符串散列-逻辑有序" class="headerlink" title="字符串散列-逻辑有序"></a>字符串散列-逻辑有序</h2><p>p109</p>
<h2 id="常用算法思想"><a href="#常用算法思想" class="headerlink" title="常用算法思想"></a>常用算法思想</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归核心：递归式，边界条件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generate</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(边界条件)&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    下一层迭代</span><br><span class="line">    e.g: generate(<span class="keyword">int</span> value+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>贪心核心：求局部最优，进而多次迭代获得全局最优</p>
<p>多需要数学证明</p>
<p><strong>贪心是思想不是具体算法</strong></p>
<h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><p>多使用有序序列</p>
<p>每次放弃一半的数据</p>
<p>将 $O(n)$ 降到 $O(log n)$</p>
<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>核心：多个枚举之间<strong>互相牵制</strong></p>
<p>前指针向下遍历的时候，每走一步都会影响后面元素的选择或范围</p>
<p>如: 规定 $a+b=X$， 指针等于 $a$ 开始遍历，后指针就等于 $X-a$</p>
<h1 id="数学问题"><a href="#数学问题" class="headerlink" title="数学问题"></a>数学问题</h1><h2 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> d = gcd(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line"><span class="keyword">int</span> c = a / d * b;</span><br></pre></td></tr></table></figure>
<h2 id="分数处理"><a href="#分数处理" class="headerlink" title="分数处理"></a>分数处理</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fraction</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> up;<span class="comment">//分子</span></span><br><span class="line">    <span class="keyword">int</span> down;<span class="comment">//分母</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h3><p>加减法<strong>通分</strong></p>
<p>乘除法正常</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li><p>输入为 0，直接判断输出</p>
</li>
<li><p>输入先化简</p>
</li>
<li><p>分母 down 为 1 时，直接输出整数</p>
</li>
<li><p>分子<strong>绝对值</strong>大于分母，为<strong>假分数</strong>，输出<strong>带分数</strong>，</p>
<p>整数: <code>up / down</code></p>
<p>分子: <code>abs(up) % down</code></p>
<p>分母: down</p>
</li>
</ul>
<h2 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h2><p>p160</p>
<h2 id="质因子分解"><a href="#质因子分解" class="headerlink" title="质因子分解"></a>质因子分解</h2><p>p161</p>
<h2 id="大整数处理-小学数学模拟"><a href="#大整数处理-小学数学模拟" class="headerlink" title="大整数处理-小学数学模拟"></a>大整数处理-小学数学模拟</h2><p>p170</p>
<h2 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h2><p>p181</p>
<h1 id="C-STL"><a href="#C-STL" class="headerlink" title="C++ STL"></a>C++ STL</h1><p><code>begin()</code> 是首地址</p>
<p><code>end()</code> 是尾地址下一位</p>
<p>即<code>[b, e)</code></p>
<p>只有 vector 和 string 支持 <code>it+n</code> 的写法</p>
<p>循环遍历结束条件是 <code>it!=v.end()</code></p>
<h2 id="vector-可变数组"><a href="#vector-可变数组" class="headerlink" title="vector 可变数组"></a>vector 可变数组</h2><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><ol>
<li>下标 <code>v[i] == *(v.begin()+i)</code></li>
<li>迭代器</li>
</ol>
<h3 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">v.push_back(x)</span><br><span class="line">v.pop_back(x)<span class="comment">//删除尾元素</span></span><br><span class="line">v.<span class="built_in">size</span>()</span><br><span class="line">v.<span class="built_in">clear</span>()</span><br><span class="line">v.insert(it, x)<span class="comment">//注意首元素是迭代器</span></span><br><span class="line">v.erase(it)</span><br><span class="line">v.erase(it, last)<span class="comment">//左闭右开</span></span><br></pre></td></tr></table></figure>
<h2 id="set-集合"><a href="#set-集合" class="headerlink" title="set 集合"></a>set 集合</h2><p>自动有序（递增），无重复元素</p>
<p>红黑树实现</p>
<h3 id="访问-1"><a href="#访问-1" class="headerlink" title="访问"></a>访问</h3><p>只能迭代器访问</p>
<h3 id="常用函数-2"><a href="#常用函数-2" class="headerlink" title="常用函数"></a>常用函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">st.insert(x)<span class="comment">//自动处理，不需要迭代器给位置</span></span><br><span class="line">st.<span class="built_in">find</span>(x)<span class="comment">//返回的是迭代器（指针）</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">typename</span>&gt;::iterator it = st.<span class="built_in">find</span>(x)</span><br><span class="line">st.erase(x)</span><br><span class="line">st.erase(it, last)<span class="comment">//可实现删除 *it 及其后所以元素</span></span><br><span class="line">st.<span class="built_in">size</span>()</span><br><span class="line">st.<span class="built_in">clear</span>()</span><br></pre></td></tr></table></figure>
<h2 id="unorder-set-无序集合"><a href="#unorder-set-无序集合" class="headerlink" title="unorder_set 无序集合"></a>unorder_set 无序集合</h2><p>无序，无重复元素</p>
<p>散列实现</p>
<p>常用函数基本同上</p>
<h2 id="string-字符串"><a href="#string-字符串" class="headerlink" title="string 字符串"></a>string 字符串</h2><p><code>#include &lt;string&gt;</code></p>
<p>输入输出只能用 cin，cout</p>
<p><code>printf()</code> 输出或用 <code>str.c_str()</code></p>
<h3 id="访问-2"><a href="#访问-2" class="headerlink" title="访问"></a>访问</h3><p><code>str[i] == *(str.begin()+i)</code></p>
<h3 id="常用函数-3"><a href="#常用函数-3" class="headerlink" title="常用函数"></a>常用函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">str += str1<span class="comment">//拼接</span></span><br><span class="line"><span class="keyword">int</span> b = str1 == str2 <span class="comment">//字典序比较大小    </span></span><br><span class="line">length() == <span class="built_in">size</span>()</span><br><span class="line">insert(pos, x)</span><br><span class="line">insert(it, it2, it3)<span class="comment">//串[it2, it3)插在it位置上</span></span><br><span class="line">erase(first, last)</span><br><span class="line">erase(pos, length)<span class="comment">//不包括pos</span></span><br><span class="line"><span class="built_in">clear</span>()</span><br><span class="line">substr(pos, len)</span><br><span class="line"><span class="built_in">find</span>(str2)</span><br><span class="line">replace(pos, len ,str2)</span><br></pre></td></tr></table></figure>
<h2 id="map-映射"><a href="#map-映射" class="headerlink" title="map 映射"></a>map 映射</h2><p>按键递增排序</p>
<p>红黑树实现</p>
<p><code>char []</code> 是数组，不能做键值</p>
<p><code>map&lt;typename, typename&gt; mp</code></p>
<h3 id="访问-3"><a href="#访问-3" class="headerlink" title="访问"></a>访问</h3><ol>
<li><p>下标（键唯一）</p>
</li>
<li><p>迭代器</p>
<p>it-&gt;first 键</p>
<p>it-&gt;second 值</p>
</li>
</ol>
<h3 id="常用函数-4"><a href="#常用函数-4" class="headerlink" title="常用函数"></a>常用函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find</span>()</span><br><span class="line">earse()</span><br><span class="line"><span class="built_in">size</span>()</span><br><span class="line"><span class="built_in">clear</span>()</span><br></pre></td></tr></table></figure>
<h2 id="unordered-map-无序映射"><a href="#unordered-map-无序映射" class="headerlink" title="unordered_map 无序映射"></a>unordered_map 无序映射</h2><p>无序</p>
<p>散列实现</p>
<p>常用函数基本同上</p>
<h2 id="queue-队列"><a href="#queue-队列" class="headerlink" title="queue 队列"></a>queue 队列</h2><h3 id="访问-4"><a href="#访问-4" class="headerlink" title="访问"></a>访问</h3><p><code>front()</code> <code>back()</code></p>
<h3 id="常用函数-5"><a href="#常用函数-5" class="headerlink" title="常用函数"></a>常用函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">push()</span><br><span class="line">pop()</span><br><span class="line">empty()</span><br><span class="line"><span class="built_in">size</span>()</span><br></pre></td></tr></table></figure>
<h2 id="priority-queue-优先队列"><a href="#priority-queue-优先队列" class="headerlink" title="priority_queue 优先队列"></a>priority_queue 优先队列</h2><p>自动有序</p>
<p>堆实现</p>
<p><code>priority_queue &lt;int, vector&lt;typename&gt; less&lt;int&gt; &gt; q</code></p>
<p><code>priority_queue &lt;int, vector&lt;typename&gt; greater&lt;int&gt; &gt; q</code></p>
<h3 id="访问-5"><a href="#访问-5" class="headerlink" title="访问"></a>访问</h3><p><code>top()</code></p>
<h2 id="stack-栈"><a href="#stack-栈" class="headerlink" title="stack 栈"></a>stack 栈</h2><p><code>top()</code> 访问</p>
<h3 id="常用函数-6"><a href="#常用函数-6" class="headerlink" title="常用函数"></a>常用函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push()</span><br><span class="line">top()</span><br><span class="line">pop()</span><br><span class="line">empty()</span><br><span class="line">size()</span><br></pre></td></tr></table></figure>
<h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><p><code>#include &lt;utility&gt;</code></p>
<p>二元结构体</p>
<h3 id="定义可直接初始化"><a href="#定义可直接初始化" class="headerlink" title="定义可直接初始化"></a>定义可直接初始化</h3><p><code>pair &lt;int, int&gt; p(1,1)</code></p>
<h3 id="访问-6"><a href="#访问-6" class="headerlink" title="访问"></a>访问</h3><p><code>p.first</code></p>
<p><code>p.second</code></p>
<h3 id="可直接比较"><a href="#可直接比较" class="headerlink" title="可直接比较"></a>可直接比较</h3><p>先比 first</p>
<p>再比 second</p>
<h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><p>多使用<strong>递归</strong>处理</p>
<p>核心：面对多种选择永远头铁一个分类的选择，如：岔路口永远左拐</p>
<h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><p>多使用<strong>队列</strong>处理</p>
<p>核心：追求广度，面面俱到</p>
<p>小技巧：队列多处理数组<strong>下标而非元素</strong></p>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>链表表示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Tree* lc;</span><br><span class="line">    Tree* rc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>数组表示</p>
<p>数组下标可以提供表示，完全不需要 <code>int id</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> lc;</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">&#125;tree[maxn];</span><br></pre></td></tr></table></figure>
<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p><strong>具有唯一性</strong></p>
<p>除了最深一层叶子，其他层全部挂满节点</p>
<h3 id="二叉树-4种遍历"><a href="#二叉树-4种遍历" class="headerlink" title="二叉树 4种遍历"></a>二叉树 4种遍历</h3><p>这里的X序遍历，指的是根节点 root 的先后顺序，而且只有 root 能获取内容</p>
<p>中序 + 先序或后序或层序  可唯一确定一棵二叉树</p>
<h3 id="先序遍历-DFS思想"><a href="#先序遍历-DFS思想" class="headerlink" title="先序遍历 - DFS思想"></a>先序遍历 - DFS思想</h3><p>第一个一定是根</p>
<p>递归实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Tree* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">get</span> root data;</span><br><span class="line">    preOrder(root-&gt;lc);</span><br><span class="line">    preOrder(root-&gt;rc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中序遍历-分左右"><a href="#中序遍历-分左右" class="headerlink" title="中序遍历 - 分左右"></a>中序遍历 - 分左右</h3><p>递归实现</p>
<p>满足二叉树分左右的性质，比较重要</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Tree* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    inOrder(root-&gt;lc);</span><br><span class="line">    <span class="built_in">get</span> root data;</span><br><span class="line">    inOrder(root-&gt;rc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="后序遍历-最后一个一定是根"><a href="#后序遍历-最后一个一定是根" class="headerlink" title="后序遍历 - 最后一个一定是根"></a>后序遍历 - 最后一个一定是根</h3><p>递归实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Tree* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    postOrder(root-&gt;lc);</span><br><span class="line">    postOrder(root-&gt;rc);</span><br><span class="line">    <span class="built_in">get</span> root data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="层序遍历-BFS思想"><a href="#层序遍历-BFS思想" class="headerlink" title="层序遍历 - BFS思想"></a>层序遍历 - BFS思想</h3><p>队列实现，可以在 <code>struct</code> 中加 <strong>深度depth</strong> 或者 <strong>层数layer</strong> 以应对深度判断</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>初始化</p>
<p>入队</p>
<p>读</p>
<p>弹</p>
<p>子树入队</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layerOrder</span><span class="params">(Tree* root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Tree*&gt; q;</span><br><span class="line">    root-&gt;layer = <span class="number">1</span>;</span><br><span class="line">    q.push(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        Tree* top = q.front();<span class="comment">//获取结点</span></span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">do</span> sth. with top;</span><br><span class="line">        <span class="comment">//左子树不空</span></span><br><span class="line">        <span class="keyword">if</span>(top-&gt;lc!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            top-&gt;lc-&gt;layer =  top-&gt;layer + <span class="number">1</span>;</span><br><span class="line">            q.push(top-&gt;lc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右子树不空</span></span><br><span class="line">        <span class="keyword">if</span>(top-&gt;rc!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            top-&gt;rc-&gt;layer = top-&gt;layer + <span class="number">1</span>;</span><br><span class="line">            q.push(top-&gt;rc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="确定二叉树"><a href="#确定二叉树" class="headerlink" title="确定二叉树"></a>确定二叉树</h3><p>中序提供左右</p>
<p>先，后，层提供根结点</p>
<p>基本步骤</p>
<ul>
<li>画图，标号下标[1, n]</li>
<li><code>Tree* create(int l, int r, int l, int y)</code> </li>
<li>如果先，中，层长度&lt;=0，直接返回</li>
<li>新建结点 root</li>
<li>在中序中找根结点 root</li>
<li>递归给 root 左右子结点</li>
<li>返回 root</li>
</ul>
<h2 id="二叉查找树-BST"><a href="#二叉查找树-BST" class="headerlink" title="二叉查找树 BST"></a>二叉查找树 BST</h2><p>中序遍历，一定有序</p>
<p>查找 $O(log n)$</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>p313</p>
<h2 id="平衡二叉树-AVL"><a href="#平衡二叉树-AVL" class="headerlink" title="平衡二叉树 - AVL"></a>平衡二叉树 - AVL</h2><p><code>struct</code> 多了一个 <code>height</code></p>
<p>当 <strong>root-&gt;left-&gt;height</strong> 与 <strong>root-&gt;left-&gt;height</strong> 差 2 时，做平衡</p>
<h3 id="4种变化"><a href="#4种变化" class="headerlink" title="4种变化"></a>4种变化</h3><p>方法论：</p>
<ol>
<li>判断哪一种旋转</li>
</ol>
<h1 id="并查集-特化树"><a href="#并查集-特化树" class="headerlink" title="并查集 - 特化树"></a>并查集 - 特化树</h1><p>如果说树是找儿子的过程</p>
<p>并查集更关心找爹</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> f[n]</span><br><span class="line">f[<span class="number">1</span>]=<span class="number">1</span> <span class="comment">//1的爹是1，1就是根结点</span></span><br><span class="line">f[<span class="number">2</span>]=<span class="number">1</span> <span class="comment">//2的爹是1</span></span><br></pre></td></tr></table></figure>
<h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><ul>
<li>判断不在一个集合</li>
<li>让 b 的根结点指向 a</li>
</ul>
<h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2><p>只关心大家的爹</p>
<p>那就每人都指向根结点</p>
<p>查询缩到 $O(1)$</p>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>比树来说，图更加自由</p>
<p>导致有环的风险，必须加 <code>vis[maxn]</code> 限制仅访问一次</p>
<p>每个结点不能保证一定被别人访问，需要 <code>Trave()</code> 保证每个结点一定能被看到一次</p>
<h2 id="DFS遍历-递归实现"><a href="#DFS遍历-递归实现" class="headerlink" title="DFS遍历 - 递归实现"></a>DFS遍历 - 递归实现</h2><h3 id="邻接矩阵版"><a href="#邻接矩阵版" class="headerlink" title="邻接矩阵版"></a>邻接矩阵版</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, G[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn] = &#123;<span class="literal">false</span>&#125;</span><br><span class="line"><span class="keyword">int</span> depth[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里 depth 没屌用，实际问题可以用 &amp;depth 获取深度，或者直接给 depth[maxn] 送过去</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">    <span class="comment">//访问该节点</span></span><br><span class="line">    vis[u]= ture;</span><br><span class="line">    </span><br><span class="line">    尝试访问其他人</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++)&#123;</span><br><span class="line">        <span class="comment">//未访问且能访问</span></span><br><span class="line">        <span class="keyword">if</span>(vis[v]==<span class="literal">false</span> &amp;&amp; G[u][v] != INF)&#123;</span><br><span class="line">            DFS(v, depth+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTrave</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>) DFS(v, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BFS遍历-队列实现"><a href="#BFS遍历-队列实现" class="headerlink" title="BFS遍历 - 队列实现"></a>BFS遍历 - 队列实现</h2><p>邻接矩阵版</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"><span class="keyword">int</span> n, G[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn] = &#123;<span class="literal">false</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> BFS(<span class="keyword">int</span> u)&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//入</span></span><br><span class="line">    q.push(u);</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="comment">//弹</span></span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//找</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[v] == <span class="literal">false</span> &amp;&amp; G[u][v] != INF)&#123;</span><br><span class="line">                q.push[v];</span><br><span class="line">                vis[v] = <span class="literal">true</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTrave</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v =<span class="number">0</span>; v &lt; n;v++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>) BFS(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><h3 id="Dijkstra算法-无负权边-（DFS遍历）"><a href="#Dijkstra算法-无负权边-（DFS遍历）" class="headerlink" title="Dijkstra算法  - 无负权边 （DFS遍历）"></a>Dijkstra算法  - 无负权边 （DFS遍历）</h3><p>找 a 到 b 的最短路径</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"><span class="keyword">int</span> n, G[maxn][maxn];<span class="comment">//可处理边权</span></span><br><span class="line"><span class="keyword">int</span> weight[maxn];<span class="comment">//处理点权</span></span><br><span class="line"><span class="keyword">int</span> d[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn];<span class="comment">//检测是否访问，防止环导致死循环</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre[maxn];<span class="comment">//最短路径递归树</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; best, tmp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//边界条件</span></span><br><span class="line">    <span class="keyword">if</span> (v == st) &#123;</span><br><span class="line">        tmp.push_back(v);</span><br><span class="line">        best = v;</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归遍历</span></span><br><span class="line">    tmp.push_back(v);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pre[v].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        DFS(pre[v][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    tmp.pop_back();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dij</span><span class="params">(<span class="keyword">int</span> st)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(d, d + maxn, INF);</span><br><span class="line">    d[st] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找N次，保证结点都能尝试判断到</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, MIN = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[j] == <span class="literal">false</span> &amp;&amp; d[j] &lt; MIN) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                MIN = d[j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (u == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">            vis[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vis[v] == <span class="literal">false</span> &amp;&amp; G[u][v] != INF) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (d[u] + G[u][v] &lt; d[v]) &#123;</span><br><span class="line">                        d[v] = d[u] + G[u][v];</span><br><span class="line">                        pre[v].<span class="built_in">clear</span>();</span><br><span class="line">                        pre[v].push_back(u);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (d[u] + G[u][v] == d[v]) &#123;</span><br><span class="line">                        pre[v].push_back(u);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2020/06/26/%E6%A0%88/</url>
    <content><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h1 id="堆栈-顺序数组实现"><a href="#堆栈-顺序数组实现" class="headerlink" title="堆栈 - 顺序数组实现"></a>堆栈 - 顺序数组实现</h1><p>堆栈本质上是特殊的线性表，只是对于元素的存取做出了一定的规定</p>
<p>起床时最先穿的内裤，睡觉时确实最后一层才能脱</p>
<p>可见生活中也有很多堆栈性质的例子</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">    <span class="keyword">int</span> maxSize;</span><br><span class="line">&#125; Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">node</span> *<span class="title">Stack</span>;</span></span><br></pre></td></tr></table></figure>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><code>top = -1</code> 时栈空</p>
<p><code>top = maxSize - 1</code> 时栈满</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Stack <span class="title">createStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">    Stack s = (Stack) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    s-&gt;data = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(maxSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    s-&gt;maxSize = maxSize;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈满判断"><a href="#栈满判断" class="headerlink" title="栈满判断"></a>栈满判断</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">(Stack s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (s-&gt;top == s-&gt;maxSize - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(Stack s, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(s)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈满"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        s-&gt;top++;</span><br><span class="line">        s-&gt;data[s-&gt;top] = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈空"><a href="#栈空" class="headerlink" title="栈空"></a>栈空</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(Stack s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (s-&gt;top == <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(Stack s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(s)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈空"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (s-&gt;data[s-&gt;top--]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>取首元素与出栈：一定是先出后取</p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>数据结构</category>
        <category>基础类型</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-A-1001</title>
    <url>/2020/06/13/PATA1001/</url>
    <content><![CDATA[<h1 id="PAT-A-1001"><a href="#PAT-A-1001" class="headerlink" title="PAT-A-1001"></a>PAT-A-1001</h1><p><a href="https://github.com/Squ1rrel-K/PAT-A-CPP" target="_blank" rel="noopener">所有甲级题全解</a></p>
<p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805528788582400" target="_blank" rel="noopener">原题链接</a></p>
<h2 id="生僻词汇："><a href="#生僻词汇：" class="headerlink" title="生僻词汇："></a>生僻词汇：</h2><p>Comma 逗号</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定 $a$，$b$，未超出 <code>int</code> 范围</p>
<p>计算出和，按要求格式化输出</p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>整数范围的把握</p>
<p>整数转字符串</p>
<p>字符串格式化处理</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用 C++ <code>string</code> 更方便</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a, b, sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//输入</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    sum = a + b;</span><br><span class="line">    <span class="built_in">string</span> str = to_string(sum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果 sum 是负数，位数应减去1</span></span><br><span class="line">    <span class="keyword">int</span> comma;</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) comma = (<span class="keyword">int</span>) (str.length() - <span class="number">2</span>) / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span> comma = (<span class="keyword">int</span>) (str.length() - <span class="number">1</span>) / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从尾部向前 3*i 位加逗号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = comma; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        str.insert(str.length() - <span class="number">3</span> * i, <span class="string">","</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PAT</category>
        <category>PAT A</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-线性表</title>
    <url>/2020/06/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>同一类型元素</p>
<p>有序</p>
<p>线性结构</p>
<h1 id="线性表顺序存储"><a href="#线性表顺序存储" class="headerlink" title="线性表顺序存储"></a>线性表顺序存储</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">node</span> *<span class="title">PtrToSqList</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToSqList List;</span><br></pre></td></tr></table></figure>
<p>用数组储存线性表</p>
<p>1024 可替换为任何合适的数</p>
<p>last 本质上是指向表尾的指针，因为数组角标的特殊性，直接使用表尾角标即可</p>
<p>C语言值传递，传递大数组显然很蠢比，不如传数组指针</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">List <span class="title">makeEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List l = (List) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;last = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>申请内存，不然空指针</p>
<p><code>last = -1</code>​ 表示表空</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(List l, <span class="keyword">int</span> <span class="built_in">position</span>, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="built_in">position</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= l-&gt;last + <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"位置非法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l-&gt;last == <span class="number">1023</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"表满"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l-&gt;last; i &gt;= index; i--) &#123;</span><br><span class="line">            l-&gt;data[i + <span class="number">1</span>] = l-&gt;data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        l-&gt;data[index] = value;</span><br><span class="line">        l-&gt;last++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>凡是数组相关的，形参有位置一定要判断是否合法</p>
<p>注意角标</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">delete</span><span class="params">(List l, <span class="keyword">int</span> <span class="built_in">position</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="built_in">position</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= l-&gt;last)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"位置非法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l-&gt;last == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"表空"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt;= l-&gt;last; i++) &#123;</span><br><span class="line">            l-&gt;data[i] = l-&gt;data[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        l-&gt;last--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="链表-线性表链式存储"><a href="#链表-线性表链式存储" class="headerlink" title="链表-线性表链式存储"></a>链表-线性表链式存储</h1><p>单链表一定要有一个空的头结点，主要目的是保持引用传递时，头结点指针不会随着第一个结点的变化而变化，进而引起不必要的维护漏洞</p>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">node</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">node</span> *<span class="title">PtrToList</span>;</span></span><br></pre></td></tr></table></figure>
<p><code>List</code> 虽然跟 <code>PtrToList</code> 定义一致，但是 <code>List</code> 侧重于其指向的内容，<code>PtrToList</code> 侧重于自己是一个指针的身份事实</p>
<h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">List <span class="title">makeEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List head = (List) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    List l = head;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>申请内存，不然空指针</p>
<p>注意 <code>l</code> 将永远指向 <code>head</code> 结点，但仅限单链表</p>
<h3 id="表长度"><a href="#表长度" class="headerlink" title="表长度"></a>表长度</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(List l)</span> </span>&#123;</span><br><span class="line">    PtrToList p = l;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑相连，动态的代价就是长度不确定性</p>
<h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(List l, <span class="keyword">int</span> <span class="built_in">position</span>, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lent = length(l);</span><br><span class="line">    PtrToList pre = l;</span><br><span class="line">    List tmp = (List) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    tmp-&gt;data = value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(<span class="built_in">position</span> &gt;= <span class="number">1</span> &amp;&amp; <span class="built_in">position</span> &lt;= lent + <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"位置非法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">position</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp-&gt;next = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = tmp;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="按位索引"><a href="#按位索引" class="headerlink" title="按位索引"></a>按位索引</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findByPosition</span><span class="params">(List l, <span class="keyword">int</span> <span class="built_in">position</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lent = length(l);</span><br><span class="line">    PtrToList p = l;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="built_in">position</span> &gt;= <span class="number">1</span> &amp;&amp; <span class="built_in">position</span> &lt;= lent)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"位置非法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">position</span>; i++) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检测位置合法性</p>
<h4 id="按值索引"><a href="#按值索引" class="headerlink" title="按值索引"></a>按值索引</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findByValue</span><span class="params">(List l, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lent = length(l);</span><br><span class="line">    PtrToList p = l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lent; i++) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没找到应该返回 <code>false</code></p>
<h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">delete</span><span class="params">(List l, <span class="keyword">int</span> <span class="built_in">position</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lent = length(l);</span><br><span class="line">    PtrToList pre = l;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="built_in">position</span> &gt;= <span class="number">1</span> &amp;&amp; <span class="built_in">position</span> &lt;= lent)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"位置非法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">position</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        PtrToList cur = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = cur-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(cur);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>数据结构</category>
        <category>线性表</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式读书笔记</title>
    <url>/2020/05/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>我一直持有一个观点：代码首先是给人看的，其次才是给机器读的，不然搞什么面向对象又是面向过程，一个文件塞满理论上也能满足计算机的要求，但是想让人看懂，易于操控，就需要理解语言创造者的苦心。而进阶的编程爱好者，对于设计模式的理解便显得弥足珍贵了，本文为多语言各种设计模式的横纵向比较分析与记录。</p>
<h1 id="创造者模式"><a href="#创造者模式" class="headerlink" title="创造者模式"></a>创造者模式</h1><p>与其说是创造对象，不如说是产品说明，此类模式关心一个实例创造前的全部内容，如同造汽车前，设计和制造流水线工程。</p>
<p><strong>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活</strong></p>
<h2 id="工厂模式-Factory-Pattern"><a href="#工厂模式-Factory-Pattern" class="headerlink" title="工厂模式 Factory Pattern"></a>工厂模式 Factory Pattern</h2><p>不涉及创造实例</p>
<p>大部分程序一直在研究的就是解耦，因为高度耦合会带来难以维护，变量联系过于紧密等问题，我们希望模块化，而不是牵一发而动全身，因此创造对象时一大堆初始化工作不应该放在业务代码里，应该有一个工厂一样的接口代为保存，这样核心业务变化的时候，不用在所有创造实例的业务里修改，只需要修改工厂即可。</p>
<h2 id="抽象工厂模式-Abstract-Factory-Pattern"><a href="#抽象工厂模式-Abstract-Factory-Pattern" class="headerlink" title="抽象工厂模式 Abstract Factory Pattern"></a>抽象工厂模式 Abstract Factory Pattern</h2><p>工厂的工厂</p>
<p>当业务复杂化后，需要对工厂本身抽象，进而满足工厂实例跟着业务实例的变化，如流水线核心不变，生产轿车还是跑车这种小细节变化，只需要实例化抽象工厂就能满足要求。</p>
<h2 id="单例模式-Singleton-Pattern"><a href="#单例模式-Singleton-Pattern" class="headerlink" title="单例模式 Singleton Pattern"></a>单例模式 Singleton Pattern</h2><p>有且只有自己存在</p>
<p>单例的核心思想是全局唯一性，本类实例化自己，且唯一，外部只能销毁和创建调用，不能去关心内部逻辑。</p>
<p>适用于全局唯一的实例，如单线程。</p>
<h2 id="建造者模式-Builder-Pattern"><a href="#建造者模式-Builder-Pattern" class="headerlink" title="建造者模式 Builder Pattern"></a>建造者模式 Builder Pattern</h2><p>核心是造变形金刚</p>
<p>变形金刚由多个部件组成，部件本身复杂多变，但是合体变形金刚的算法或者结构却是相对简单的，这时考虑使用建造者模式。</p>
<p>比起工厂模式更关心部件的组装顺序。</p>
<h2 id="原型模式-Prototype-Pattern"><a href="#原型模式-Prototype-Pattern" class="headerlink" title="原型模式 Prototype Pattern"></a>原型模式 Prototype Pattern</h2><p>克隆人</p>
<p>当新建对象代价很大的时候，对象需要复用时使用。</p>
<p>如一个对象需要在一个高代价的数据库操作之后被创建。可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p>
<h2 id="对象池模式-Pool"><a href="#对象池模式-Pool" class="headerlink" title="对象池模式 Pool"></a>对象池模式 Pool</h2><p>水库存水</p>
<p>老是用水龙头取水，水龙头容易坏，还容易无法满足需求，先搞个水库，把常用对象扔进去，异步的存取使用，避免同步操作带来的消耗。</p>
<p>如：线程池、数据库连接池、任务队列池、图片资源对象池。</p>
<p>举例：laravel 的邮件发送是同步的，修改成一个队列池，每个新请求会被放到池子里，服务器可以从容不迫的 FIFO 处理任务。 </p>
<h2 id="多例模式-Multiton"><a href="#多例模式-Multiton" class="headerlink" title="多例模式 Multiton"></a>多例模式 Multiton</h2><p>包含多个实例的单例模式</p>
<p>如多个数据库链接。</p>
<h2 id="静态工厂模式-Static-Factory"><a href="#静态工厂模式-Static-Factory" class="headerlink" title="静态工厂模式 Static Factory"></a>静态工厂模式 Static Factory</h2><p>针对静态资源的工厂模式</p>
<h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><h2 id="适配器模式-Adapter-Pattern"><a href="#适配器模式-Adapter-Pattern" class="headerlink" title="适配器模式 Adapter Pattern"></a>适配器模式 Adapter Pattern</h2><p>电力中的转换器也是相同思路，220v 换成 120v 需要一个接口处理，就是适配器。</p>
<p>当年写 Android 的时候，适配器是必须掌握的知识。</p>
<p>缺点就是反常规，看不懂会奇怪，明明 A 类的资源，怎么扔 B 类还能用？</p>
<h2 id="桥接模式-bridge-Pattern"><a href="#桥接模式-bridge-Pattern" class="headerlink" title="桥接模式  bridge Pattern"></a>桥接模式  bridge Pattern</h2><p>桥接的核心思路是将抽象与行为解耦，从继承关系弱化为关联模式</p>
<p>如一个实例面临多个并列行为的关系时，可以用桥接，如设计一杯饮料，杯子大小，饮料内容，配料均有多个选择，使用桥接很适合。</p>
<h2 id="共享模式-Flyweight"><a href="#共享模式-Flyweight" class="headerlink" title="共享模式 Flyweight"></a>共享模式 Flyweight</h2><p>核心是高度重复资源的可重复利用性，多跟工厂模式共用，当遇到请求时，首先检索共享池里是否有合适对象，否则创造并返回。</p>
<p>面临高度重复的请求时，最大程度减少资源开销。</p>
<h2 id="装饰模式-Decorator"><a href="#装饰模式-Decorator" class="headerlink" title="装饰模式 Decorator"></a>装饰模式 Decorator</h2><p>动态基于对象新的功能，像打补丁一样，不在意被装饰对象本身细节。</p>
<p>相当于万智牌的合变放在下面，下面的生物只给了异能，别的啥事没干。</p>
<h2 id="组合模式-Composite"><a href="#组合模式-Composite" class="headerlink" title="组合模式 Composite"></a>组合模式 Composite</h2><p>本质上是树形结构的封装利用，利用树形结构的访问速度优势，迭代得获取各组件。</p>
<p>非叶节点也可以看成另一个组构体。</p>
<h2 id="代理模式-Proxy-Pattern"><a href="#代理模式-Proxy-Pattern" class="headerlink" title="代理模式 Proxy Pattern"></a>代理模式 Proxy Pattern</h2><p>核心在于请求本身涉及安全性或者大花销等问题，需要代理看看给不给权限，不然对象造完了再研究给不给权限就没什么意义了。</p>
<p>相当于请个管家管一下。</p>
<h2 id="外观模式-Facade"><a href="#外观模式-Facade" class="headerlink" title="外观模式 Facade"></a>外观模式 Facade</h2><p>比起小管家，Facade 是总管，对一个系统的访问做整理跟统筹，最大程度降耦，保证子系统自由性。</p>
<h1 id="行为类模式"><a href="#行为类模式" class="headerlink" title="行为类模式"></a>行为类模式</h1><h2 id="迭代模式-Iterator"><a href="#迭代模式-Iterator" class="headerlink" title="迭代模式 Iterator"></a>迭代模式 Iterator</h2><p>迭代器的抽象，没啥好说的，核心在于不暴露内部结构的遍历。</p>
<h2 id="模板模式-Template"><a href="#模板模式-Template" class="headerlink" title="模板模式 Template"></a>模板模式 Template</h2><p>定义操作骨架，通过继承丰富内容或者实现。</p>
<p>抽象类常用思想，定义却不完化，给予后人补充说明。</p>
<h2 id="责任链-Chain-of-Responsibility"><a href="#责任链-Chain-of-Responsibility" class="headerlink" title="责任链 Chain of Responsibility"></a>责任链 Chain of Responsibility</h2><p>请求来源高度不确定性，使用 cor 可以使链上任意一个类的负担不至于过重，统一一个 handler 分配工作。</p>
<h2 id="备忘模式-Memento"><a href="#备忘模式-Memento" class="headerlink" title="备忘模式 Memento"></a>备忘模式 Memento</h2><p>可能二次需要的内容做保存。</p>
<p>如 laravel 中的 <code>old()</code>方法。</p>
<h2 id="中介者-Mediator"><a href="#中介者-Mediator" class="headerlink" title="中介者 Mediator"></a>中介者 Mediator</h2><p>各个对象之间的交互操作非常多;每个对象的行为操作都依赖彼此对方,修改一个对象的行 为,同时会涉及到修改很多其他对象的行为。</p>
<p>如 laravel 中的 <code>Controller</code></p>
<h2 id="解释器-Interpreter"><a href="#解释器-Interpreter" class="headerlink" title="解释器 Interpreter"></a>解释器 Interpreter</h2><p>很少会用到，关注于非可识别语言的解释，如正则，表达式等。</p>
<h2 id="策略模式-Strategy"><a href="#策略模式-Strategy" class="headerlink" title="策略模式 Strategy"></a>策略模式 Strategy</h2><p>也叫算法簇模式，针对不同需求，有策略的分派不同算法解决问题。</p>
<h2 id="状态模式-State"><a href="#状态模式-State" class="headerlink" title="状态模式 State"></a>状态模式 State</h2><p>就是状态机。</p>
<h2 id="观察者-Observer"><a href="#观察者-Observer" class="headerlink" title="观察者 Observer"></a>观察者 Observer</h2><p>常驻内存检测变化，一旦变化就触发。</p>
<h2 id="访问者模式-visitor"><a href="#访问者模式-visitor" class="headerlink" title="访问者模式 visitor"></a>访问者模式 visitor</h2><p>作用于某个对象群中各个对象的操作. 它可以使你在不改变这些对象本身的情况下,定义 作用于这些对象的新操作. </p>
<h2 id="命令模式-Command"><a href="#命令模式-Command" class="headerlink" title="命令模式 Command"></a>命令模式 Command</h2><p>Laravel 中的 Artisan 是很典型的命令模式，请求对象化。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>终于修好了</title>
    <url>/2020/05/18/%E7%BB%88%E4%BA%8E%E4%BF%AE%E5%A5%BD%E4%BA%86/</url>
    <content><![CDATA[<h1 id="博客终于修好了"><a href="#博客终于修好了" class="headerlink" title="博客终于修好了"></a>博客终于修好了</h1><p>问题是我用的别的博主的主题，本身是一个 git 仓库，github 的仓库嵌套，内层会被 <code>git add -A</code> 忽略。</p>
]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>Bootstrap4 读书笔记</title>
    <url>/2020/04/20/Bootstrap4-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Bootstrap4-学习笔记"><a href="#Bootstrap4-学习笔记" class="headerlink" title="Bootstrap4 学习笔记"></a>Bootstrap4 学习笔记</h1>]]></content>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1007</title>
    <url>/2020/01/29/PAT-B-1007/</url>
    <content><![CDATA[<h1 id="1007-素数对猜想"><a href="#1007-素数对猜想" class="headerlink" title="1007 素数对猜想"></a>1007 素数对猜想</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>让我们定义 $d<em>n$ 为：$d_n=p</em>{n+1} −p_n$，其中 $p_i$ 是第 $i$ 个素数。显然有$d_1=1$，且对于 n&gt;1 有 $d_n$ 是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。</p>
<p>现给定任意正整数 N (&lt;$10^5$ )，请计算不超过N的满足猜想的素数对的个数。</p>
<h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>输入在一行给出正整数N。</p>
<h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>在一行中输出不超过N的满足猜想的素数对的个数。</p>
<h2 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h2><p>20</p>
<h2 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h2><p>4</p>
<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>暴力检索显然是 $O(n^2)$，但是只要黎曼猜想还叫黎曼猜想，素数分布情况就还是没被完全发掘的</p>
<p>先暴力一下，以后继续寻找其他方法</p>
<h2 id="代码一-5-6"><a href="#代码一-5-6" class="headerlink" title="代码一 (5/6)"></a>代码一 (5/6)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; num; i+=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime(i) &amp;&amp; isPrime(i + <span class="number">2</span>)) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PAT</category>
        <category>PAT B</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1006</title>
    <url>/2020/01/29/PAT-B-1006/</url>
    <content><![CDATA[<h1 id="1006-换个格式输出整数"><a href="#1006-换个格式输出整数" class="headerlink" title="1006 换个格式输出整数"></a>1006 换个格式输出整数</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>让我们用字母 B 来表示“百”、字母 S 表示“十”，用 12…n 来表示不为零的个位数字 n（&lt;10），换个格式来输出任一个不超过 3 位的正整数。例如 234 应该被输出为 BBSSS1234，因为它有 2 个“百”、3 个“十”、以及个位的 4。</p>
<h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>每个测试输入包含 1 个测试用例，给出正整数 n（&lt;1000）。</p>
<h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>每个测试用例的输出占一行，用规定的格式输出 n。</p>
<h2 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h2><p>234</p>
<h2 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h2><p>BBSSS1234</p>
<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>简单题，按编码顺序求各个数位即可</p>
<h2 id="举一反三"><a href="#举一反三" class="headerlink" title="举一反三"></a>举一反三</h2><p>显然非十进制数也可如此处理</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">    <span class="keyword">int</span> g = num % <span class="number">10</span>;</span><br><span class="line">    num = (num - g) / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> s = num % <span class="number">10</span>;</span><br><span class="line">    num = (num - s) / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b = num % <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (b--) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"B"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (s--) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"S"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=g; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PAT</category>
        <category>PAT B</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>新年计划</title>
    <url>/2020/01/27/%E6%96%B0%E5%B9%B4%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h1 id="新年计划"><a href="#新年计划" class="headerlink" title="新年计划"></a>新年计划</h1><p>新的一年，最大的愿望就是摆脱浮躁，一次只做一件事，一次做好一件事。</p>
<p>洗去浮华，从头开始；惜时如命，夯实基础。</p>
]]></content>
      <tags>
        <tag>plan</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1004</title>
    <url>/2020/01/27/PAT-B-1004/</url>
    <content><![CDATA[<h1 id="1004-成绩排名-20分"><a href="#1004-成绩排名-20分" class="headerlink" title="1004 成绩排名 (20分)"></a>1004 成绩排名 (20分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>读入 n（&gt;0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。</p>
<h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>每个测试输入包含 1 个测试用例，格式为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第 1 行：正整数 n</span><br><span class="line">第 2 行：第 1 个学生的姓名 学号 成绩</span><br><span class="line">第 3 行：第 2 个学生的姓名 学号 成绩</span><br><span class="line">  ... ... ...</span><br><span class="line">第 n+1 行：第 n 个学生的姓名 学号 成绩</span><br></pre></td></tr></table></figure>
<p>其中姓名和学号均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。</p>
<h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>对每个测试用例输出 2 行，第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。</p>
<h2 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h2><p>3</p>
<p>Joe Math990112 89</p>
<p>Mike CS991301 100</p>
<p>Mary EE990830 95</p>
<h2 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h2><p>Mike CS991301</p>
<p>Joe Math990112</p>
<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>此题考查对对输入输出流的把握能力</p>
<p>对于不属于同一数据类型的变量使用结构体把控</p>
<p>即 max min tem 3项</p>
<p>注意题干，无相同成绩</p>
<p>注意第一层循环就要用tem 替换 max min 保证不为空</p>
<h2 id="举一反三"><a href="#举一反三" class="headerlink" title="举一反三"></a>举一反三</h2><p><code>std</code> 的 <code>cin</code> 只会读到下一个空格或是换行符 <code>$</code>，如果需要一次读一行需要使用 <code>getline()</code> 函数</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name, id;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    student tem;</span><br><span class="line">    student <span class="built_in">max</span>&#123;<span class="string">""</span>, <span class="string">""</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    student <span class="built_in">min</span>&#123;<span class="string">""</span>, <span class="string">""</span>, <span class="number">100</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tem.name &gt;&gt; tem.id &gt;&gt; tem.score;</span><br><span class="line">        <span class="built_in">max</span> = tem.score &gt; <span class="built_in">max</span>.score ? tem : <span class="built_in">max</span>;</span><br><span class="line">        <span class="built_in">min</span> = tem.score &lt; <span class="built_in">min</span>.score ? tem : <span class="built_in">min</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">max</span>.name &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">max</span>.id &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">min</span>.name &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">min</span>.id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PAT</category>
        <category>PAT B</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1003</title>
    <url>/2020/01/27/PAT-B-1003/</url>
    <content><![CDATA[<h1 id="1003-我要通过！"><a href="#1003-我要通过！" class="headerlink" title="1003 我要通过！"></a>1003 我要通过！</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>“答案正确” 是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。</p>
<p>得到“答案正确”的条件是：</p>
<ol>
<li><p>字符串中必须仅有 P、 A、 T这三种字符，不可以包含其它字符；</p>
</li>
<li><p>任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串；</p>
</li>
<li><p>如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a、 b、 c 均或者是空字符串，或者是仅由字母 A 组成的字符串。</p>
</li>
</ol>
<p>现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。</p>
<h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 n (&lt;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。</p>
<h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出 YES，否则输出 NO。</p>
<h2 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h2><p>8</p>
<p>PAT</p>
<p>PAAT</p>
<p>AAPATAA</p>
<p>AAPAATAAAA</p>
<p>xPATx</p>
<p>PT</p>
<p>Whatever</p>
<p>APAAATAA</p>
<h2 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h2><p>YES</p>
<p>YES</p>
<p>YES</p>
<p>YES</p>
<p>NO</p>
<p>NO</p>
<p>NO</p>
<p>NO</p>
<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>这题我想复杂了，看到条件二 xPATx 不自觉想到正则表达式的反向引用，但是条件三用正则比较复杂，虽然此题 AC 了，但是做的实在是很不漂亮，以后有时间还得重新研究一下。</p>
<p> 条件1，2都非常简单</p>
<p>条件3要难点在于条件是递归式的，简单计算易得， a * b = c</p>
<p>c++ 应该使用 “.” 保证转义，如 <code>.1</code></p>
<p>正则搜索迭代器 <code>regex_search()</code> 注意不能用 “A*” 等无底线要求，会无限迭代</p>
<p> 最后输出注意空行 <code>\n</code></p>
<h2 id="举一反三"><a href="#举一反三" class="headerlink" title="举一反三"></a>举一反三</h2><p> 正则虽好，其局限性也要在考虑范围内</p>
<p> 推荐一本正则表达式的阅读书籍，我已经看完了，写的非常好:<br><a href="https://baike.baidu.com/item/%E7%B2%BE%E9%80%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89/8496437?fr=aladdin" target="_blank" rel="noopener">精通正则表达式</a></p>
<p>我这边有复印版，想要的朋友也可以联系我</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="comment">/*注意事项：</span></span><br><span class="line"><span class="comment"> * 条件1，2都非常简单</span></span><br><span class="line"><span class="comment"> * 条件3要难点在于条件是递归式的，简单计算易得， a * b = c</span></span><br><span class="line"><span class="comment"> * c++ 应该使用 "\\" 保证转义，如 "\\1"</span></span><br><span class="line"><span class="comment"> * 正则迭代器注意不能用 "A*" 等无底线要求，会无限迭代</span></span><br><span class="line"><span class="comment"> * 最后输出注意空行 "\n"</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="function">regex <span class="title">regex_1</span><span class="params">(<span class="string">"[P|A|T]+"</span>)</span></span>;<span class="comment">//满足条件一</span></span><br><span class="line"><span class="function">regex <span class="title">regex_2</span><span class="params">(<span class="string">"(A*)PAT\\1"</span>)</span></span>;<span class="comment">//满足条件二直接输出</span></span><br><span class="line"><span class="function">regex <span class="title">regex_3</span><span class="params">(<span class="string">"A*PA+TA*"</span>)</span></span>;<span class="comment">//条件三的大前提</span></span><br><span class="line"><span class="function">regex <span class="title">regex_4</span><span class="params">(<span class="string">"A+"</span>)</span></span>;<span class="comment">//找到 A 的数量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkString</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> r1, r2, r3, r4;</span><br><span class="line">    smatch result;</span><br><span class="line">    <span class="built_in">string</span> temp[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">string</span>::const_iterator iterStart = str.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">string</span>::const_iterator iterEnd = str.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">    r1 = regex_match(str, regex_1);</span><br><span class="line">    r2 = regex_match(str, regex_2);</span><br><span class="line">    r3 = regex_match(str, regex_3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用迭代器，将正则匹配到的结果存在 temp[] 里</span></span><br><span class="line">    <span class="keyword">while</span> (regex_search(iterStart, iterEnd, result, regex_4)) &#123;</span><br><span class="line">        temp[i++] = result[<span class="number">0</span>];</span><br><span class="line">        iterStart = result[<span class="number">0</span>].second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//满足 a * b = c</span></span><br><span class="line">    r4 = ((temp[<span class="number">0</span>].<span class="built_in">size</span>() * temp[<span class="number">1</span>].<span class="built_in">size</span>() == temp[<span class="number">2</span>].<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//r1 必须满足，r2 或 r3 &amp;&amp; r4 满足即可</span></span><br><span class="line">    <span class="keyword">if</span> (r1 &amp;&amp; (r2 || (r3 &amp;&amp; r4))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">    <span class="built_in">string</span> arr[num];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">        <span class="keyword">if</span> (checkString(str)) &#123;</span><br><span class="line">            arr[i] = <span class="string">"YES"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> arr[i] = <span class="string">"NO"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PAT</category>
        <category>PAT B</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1002</title>
    <url>/2020/01/27/PAT-B-1002/</url>
    <content><![CDATA[<h1 id="1002-写出这个数-20分"><a href="#1002-写出这个数-20分" class="headerlink" title="1002 写出这个数 (20分)"></a>1002 写出这个数 (20分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>读入一个正整数 n，计算其各位数字之和，用汉语拼音写出和的每一位数字。</p>
<h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>每个测试输入包含 1 个测试用例，即给出自然数 n 的值。这里保证 n 小于 10^100</p>
<h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>在一行内输出 n 的各位数字之和的每一位，拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。</p>
<h2 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h2><p>1234567890987654321123456789</p>
<h2 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h2><p>yi san wu</p>
<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>考察的重点其实是 string char 和 int 来回转换</p>
<p>读取求和即可，注意末位没有空格</p>
<h2 id="举一反三"><a href="#举一反三" class="headerlink" title="举一反三"></a>举一反三</h2><p>一个利用 ASCII 取巧的方法：</p>
<p>本质上是各字符编码的号的距离</p>
<p>想从<code>char</code> 获得<code>int</code>，使用<code>-&#39;0&#39;</code></p>
<p>如 <code>1 = &#39;1&#39;-&#39;0&#39;</code></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> input;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> arr[<span class="number">10</span>] = &#123;</span><br><span class="line">            <span class="string">"ling"</span>, <span class="string">"yi"</span>, <span class="string">"er"</span>, <span class="string">"san"</span>, <span class="string">"si"</span>, <span class="string">"wu"</span>, <span class="string">"liu"</span>, <span class="string">"qi"</span>, <span class="string">"ba"</span>, <span class="string">"jiu"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; input;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        sum += input[i] - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> res = to_string(sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// If reach the end, cout end</span></span><br><span class="line">        <span class="keyword">if</span> (i == res.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; arr[res[i] - <span class="string">'0'</span>];</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">// else print number and space</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; arr[res[i] - <span class="string">'0'</span>];</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PAT</category>
        <category>PAT B</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>使用数学工具来定义</title>
    <url>/2020/01/26/%E4%BD%BF%E7%94%A8%E6%95%B0%E5%AD%A6%E5%B7%A5%E5%85%B7%E6%9D%A5%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<h2 id="算法复杂度：-S-n-与-T-n"><a href="#算法复杂度：-S-n-与-T-n" class="headerlink" title="算法复杂度：$S(n)$ 与 $T(n)$"></a>算法复杂度：$S(n)$ 与 $T(n)$</h2><p>复杂度的观察应该是宏观的，不用纠结于每行代码运行时的消耗，而是从另一个高度把握。</p>
<h3 id="空间复杂度-S-n"><a href="#空间复杂度-S-n" class="headerlink" title="空间复杂度 $S(n)$"></a>空间复杂度 $S(n)$</h3><p>我们做一个简单的规定：$S(n)$ 为算法的空间复杂度，观察程序执行时占用储存单元的长度。n 即为数据的规模，显然复杂度过高会吃爆内存造成程序中断。</p>
<p>现代计算机 pc 内存多以 GB 为单位，程序的空间占用不是这么紧缺。换言之，空间复杂度为一般程序次要的考察因素。</p>
<p>嵌入式开发，大型服务器运维，仍需要考虑空间分配。</p>
<h3 id="时间复杂度-T-n"><a href="#时间复杂度-T-n" class="headerlink" title="时间复杂度 $T(n)$"></a>时间复杂度 $T(n)$</h3><p>$T(n)$ 关注的是程序的运行时间与数据规模 n 的 关系，无论时代如何发展，只要人们不能减速时间，时间消耗就还是最重要的程序消耗，当然，计算机的发展会加快计算速度，并提升 cpu 带宽，但是与如今程序规模的发展相比，仍是杯水车薪。大量并发，亿万级大数据已成主流，时间就是金钱。</p>
<p>所以，对程序时间消耗有更强的掌控力已经是程序员的必修课。</p>
<h3 id="最小上界-O-n"><a href="#最小上界-O-n" class="headerlink" title="最小上界 $O(n)$"></a>最小上界 $O(n)$</h3><p>关于上下界的严格数学证明不再赘述</p>
<p>引入 $O(n)$ 作为对程序时间复杂度的粗略上界估计，$O(n)$ 为最小上界</p>
<h3 id="算法的渐进表示"><a href="#算法的渐进表示" class="headerlink" title="算法的渐进表示"></a>算法的渐进表示</h3><ol>
<li>算法加和，考虑更慢的一边</li>
<li>算法的嵌套，复杂度做乘法</li>
<li>$T(n)$ 是 n 的 k 阶多项式，$T(n)=\Theta(n^k)$</li>
<li>for 循环嵌套，$T(n)$ 为各层循环次数的积再乘以循环体复杂度</li>
<li>if-else 结构考虑条件，两个分支，三者中最慢的一个。</li>
</ol>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>我们为什么要学习数据结构和算法</title>
    <url>/2020/01/25/%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="首先做一个小小的假设"><a href="#首先做一个小小的假设" class="headerlink" title="首先做一个小小的假设"></a>首先做一个小小的假设</h2><p>我们假设有一台运行速度足够快，内存足够大的电脑（突破普朗克常量物理极限，达到数学层面的无限），快到可以瞬间做完任何任务，大到可以塞下任何程序栈，那么我们从此似乎不再需要继续钻研数据结构和算法了，暴力求解，暴力递归就是一切，显然，这样的电脑是不存在的。</p>
<p>举这个例子就是想说明：数据结构和算法问题必须放在具体时空条件下，具体情况具体分析，所以我们爱用优化这个词，我们倾向于用更少的空间，更少的时间，做更多的计算，理论上软件优化是有极限的，因为总要给磁盘，内存，cpu 物理工作的时间。</p>
<p>我们碰到的问题无非是在受限的时空条件下，完成目标的计算任务，或是基于源程序做定向优化。</p>
<h2 id="那么总得有个标准吧"><a href="#那么总得有个标准吧" class="headerlink" title="那么总得有个标准吧"></a>那么总得有个标准吧</h2><h3 id="定标准看起来是一件比较容易的事："><a href="#定标准看起来是一件比较容易的事：" class="headerlink" title="定标准看起来是一件比较容易的事："></a>定标准看起来是一件比较容易的事：</h3><p>时间嘛，看程序运行多少毫秒就完事了，快就是好。</p>
<p>空间嘛，看占了多少 bit，少就是好。</p>
<h3 id="似乎很有道理，仔细琢磨一下有这样一个问题："><a href="#似乎很有道理，仔细琢磨一下有这样一个问题：" class="headerlink" title="似乎很有道理，仔细琢磨一下有这样一个问题："></a>似乎很有道理，仔细琢磨一下有这样一个问题：</h3><p>程序 A 在数据量比较小的情况下时空消耗都还好，感觉数据量增大了也不多，消耗却像细胞分裂一样吃掉了远远高于预期的资源，慢慢尝试后我们会发现，隐隐约约消耗与数据量有着函数关系式的对应，或是线性，或是呈指数。</p>
<p>于是为了抛弃上面那种粗略量化的糟粕，我们有了更精确的定性定量的工具。</p>
<h2 id="引入一个数学工具来帮助我们"><a href="#引入一个数学工具来帮助我们" class="headerlink" title="引入一个数学工具来帮助我们"></a>引入一个数学工具来帮助我们</h2><p>离散数学讨论了这样一个问题：$y=x$ 和 $y=x^2$，当 x 越来越大时，谁增长的更快呢？</p>
<p>显然是 $x ^ 2$，那么当我们研究一个 $y = 2x + 3x ^ 2$，这样的问题时，是不是可以忽略 $2x$ 这项的消耗呢？</p>
<p>举个简单的例子，小胖和小美一起吃饭，当两人吃的时间足够长，东西足够多的时候，我们是不是可以断言，伙食费里面的绝大部分都是小胖吃的？</p>
<p>所以一个很聪明的办法是在更大的损耗面前，忽略那些不这么重要的消耗。</p>
<p>而算法导论等著作中，关于时空消耗有着非常清晰且规整的介绍!</p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1001</title>
    <url>/2020/01/25/PAT-B-1001/</url>
    <content><![CDATA[<h1 id="1001-害死人不偿命的-3n-1-猜想-15分"><a href="#1001-害死人不偿命的-3n-1-猜想-15分" class="headerlink" title="1001 害死人不偿命的(3n+1)猜想 (15分)"></a>1001 害死人不偿命的(3n+1)猜想 (15分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="卡拉兹-Callatz-猜想："><a href="#卡拉兹-Callatz-猜想：" class="headerlink" title="卡拉兹(Callatz)猜想："></a>卡拉兹(Callatz)猜想：</h3><p>对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……</p>
<p>我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 n，简单地数一下，需要多少步（砍几下）才能得到 n=1？         </p>
<h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>每个测试输入包含 1 个测试用例，即给出正整数 n 的值。 </p>
<h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>输出从 n 计算到 1 需要的步数。</p>
<h2 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h2><p>3</p>
<h2 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h2><p>5 </p>
<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>简单题，按要求处理即可</p>
<h2 id="举一反三"><a href="#举一反三" class="headerlink" title="举一反三"></a>举一反三</h2><p>查了一下，卡拉兹 (Callatz) 猜想依然没有被证实</p>
<p>算法越做越发现其实全是数学问题，计算机能做的事情是有边界的 (如停机问题)，只能从有限的条件到有限的结果</p>
<p>因此我们需要数学才能触碰事物的一般性</p>
<p>我永远记得当年绞尽脑汁研究斐波那契数列如何递归不吃满内存限制时，朋友把通项公式发给我时的骚样子</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            n = n / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            n = (<span class="number">3</span> * n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PAT</category>
        <category>PAT B</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/01/25/Hello-World/</url>
    <content><![CDATA[<p>$xyz$</p>
]]></content>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
</search>
